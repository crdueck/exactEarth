<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="section slide level1" id="functional-programming">
<h1 id="functional-programming">Functional Programming:</h1>
<h2 id="come-for-the-sandwiches-stay-for-the-functions">Come for the sandwiches, stay for the functions</h2>
</div>
<div class="section slide level1" id="what-is-functional-programming">
<h1 id="what-is-functional-programming">What is Functional Programming?</h1>
<p>Functional programming is a style of programming that encourages</p>
<ul>
<li><p>pure functions: &quot;mathematical&quot; functions that depend only on their inputs, not the global program/world state.</p></li>
<li><p>immutable data structures: once defined, data cannot be mutated. Instead, a new modified copy of the data is created.</p></li>
<li><p>declarative style: describe &quot;what&quot; the solution to a problem is, not &quot;how&quot; to do it.</p></li>
<li><p>implicit recursion: recursion is used instead of iteration, but higher order functions (functions that take functions as arguments to change their behaviour) abstract explicit recursion away.</p></li>
</ul>
</div>
<div class="section slide level1" id="why-use-functional-programming">
<h1 id="why-use-functional-programming">Why Use Functional Programming?</h1>
<p>Correct use of a functional style results in code that is easier to maintain and reason about.</p>
<p>Functional code is often &quot;obviously&quot; correct and very composable and reusable due to the use of higher order functions.</p>
<p>Pure functions and immutable data structures reduce the cognitive load required to understand a piece of code. The behaviour of a function will never depend on a global variable defined halfway across the code base, or the current state of the program. Everything a programmer needs to reason about a piece of code is self contained.</p>
<p>All the code we will ever write will eventually be executed on some inherently procedural CPU. However, our code will also have to be modified many times over by other programmers to add new features, fix bugs and optimize for performance.</p>
<p>Functional programming lets us write clear, correct code that is easy to maintain, while letting powerful optimizing compilers do the &quot;busy work&quot; of translating our high level code for humans to low level code for machines.</p>
</div>
<div class="section slide level1" id="haskell-at-a-glance">
<h1 id="haskell-at-a-glance">Haskell at a Glance</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> <span class="dt">List</span> a
<span class="co">-- []  :: List a</span>
<span class="co">-- (:) :: a -&gt; List a -&gt; List a</span>

<span class="ot">myList ::</span> [<span class="dt">Int</span>]
myList <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span> <span class="fu">:</span> (<span class="dv">3</span> <span class="fu">:</span> []))
<span class="co">-- or myList = [1, 2, 3]</span>
<span class="co">-- or myList = [1..3]</span>

<span class="co">-- pattern matching</span>
<span class="fu">null</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">null</span> []     <span class="fu">=</span> <span class="kw">True</span>
<span class="fu">null</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">False</span>

<span class="co">-- curried function</span>
<span class="ot">add3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add3 x y z <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">+</span> z

<span class="co">-- partially applied function</span>
<span class="ot">add2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add2 <span class="fu">=</span> add3 <span class="dv">0</span>

<span class="co">-- wildcards</span>
<span class="fu">const</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
<span class="fu">const</span> x _ <span class="fu">=</span> x</code></pre>
</div>
<div class="section slide level1" id="essential-higher-order-functions">
<h1 id="essential-higher-order-functions">Essential Higher Order Functions</h1>
<p>There are some very frequently used higher order functions that capture common recursive operations over <code>List</code>. We'll see later that most of these functions can be generalized to work on other data structures besides <code>List</code>.</p>
<h2 id="map">Map</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="fu">map</span> _ []     <span class="fu">=</span> []
<span class="fu">map</span> f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> <span class="fu">map</span> f xs</code></pre>
<p>Let's apply <code>map</code> step by step to see how it works.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span> <span class="fu">odd</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">map</span> <span class="fu">odd</span> [<span class="dv">2</span>,<span class="dv">3</span>]
                <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">2</span> <span class="fu">:</span> <span class="fu">map</span> <span class="fu">odd</span> [<span class="dv">3</span>]
                <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">2</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">3</span> <span class="fu">:</span> <span class="fu">map</span> <span class="fu">odd</span> []
                <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">2</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">3</span> <span class="fu">:</span> []
                <span class="fu">=</span> [<span class="kw">True</span>, <span class="kw">False</span>, <span class="kw">True</span>]</code></pre>
<p>Basically, <code>map</code> returns a new <code>List</code> where each element in the input <code>List</code> has been replaced with the result of applying the function to that element.</p>
</div>
<div class="section slide level1" id="map-1">
<h1 id="map-1">Map</h1>
<p>Suppose we have a <code>List</code> of input data. We want to process each item in some way and store the results in a new <code>List</code>. We might do this using the following imperative code.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">processList</span>(input: List[Input]) : List[Output] = {
    <span class="kw">var</span> out = <span class="kw">new</span> List[Output]()

    <span class="kw">for</span> (data &lt;- input) {
        out += <span class="fu">processData</span>(data)
    }
    <span class="kw">return</span> out
}</code></pre>
<p>Now a functional version using <code>map</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">processList</span>(input: List[Input]) : List[Output] = {
   input.<span class="fu">map</span>(processData)
}</code></pre>
<p>Using <code>map</code> improves code readability. It may be hard to tell what a handwritten for loop does at a glance, but <code>map</code>:</p>
<ul>
<li>always traverses each element</li>
<li>always applies the same function to each element in the same way</li>
</ul>
</div>
<div class="section slide level1" id="quick-note-on-scala-anonymous-functions">
<h1 id="quick-note-on-scala-anonymous-functions">Quick Note on Scala Anonymous Functions</h1>
<p>The following functions are all equivalent.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(x =&gt; x + <span class="dv">1</span>)

List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(_ + <span class="dv">1</span>)

<span class="co">// def add1(x: Int) = x + 1</span>

List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(x =&gt; <span class="fu">add1</span>(x))

List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(add1)</code></pre>
</div>
<div class="section slide level1" id="filter">
<h1 id="filter">Filter</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">filter</span> _ []     <span class="fu">=</span> []
<span class="fu">filter</span> p (x<span class="fu">:</span>xs) <span class="fu">=</span>
    <span class="kw">if</span> p x
       <span class="kw">then</span> x <span class="fu">:</span> <span class="fu">filter</span> p xs
       <span class="kw">else</span>     <span class="fu">filter</span> p xs</code></pre>
<p>Let apply <code>filter</code> step by step to see how it works.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">filter</span> <span class="fu">odd</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">odd</span> [<span class="dv">2</span>,<span class="dv">3</span>]  <span class="co">-- 1 is odd</span>
                   <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">odd</span> [<span class="dv">3</span>]    <span class="co">-- 2 is not odd</span>
                   <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">odd</span> [] <span class="co">-- 3 is odd</span>
                   <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> []
                   <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">3</span>]</code></pre>
<p>An iterative function to remove odd numbers from a <code>List</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onlyEvens</span>(xs: List[Int]) : List[Int] = {
    <span class="kw">var</span> acc = <span class="kw">new</span> List[Int]()
    <span class="kw">for</span> (x &lt;- xs) {
        <span class="kw">if</span> (x % <span class="dv">2</span> == <span class="dv">0</span>) {
            acc += x
        }
    }
    <span class="kw">return</span> acc
}</code></pre>
<p>and a functional version using <code>filter</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onlyEvens</span>(xs: List[Int]) : List[Int] = {
    xs.<span class="fu">filter</span>(_ % <span class="dv">2</span> == <span class="dv">0</span>)
}</code></pre>
</div>
<div class="section slide level1" id="foldr">
<h1 id="foldr">Foldr</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
<span class="fu">foldr</span> _ acc []     <span class="fu">=</span> acc
<span class="fu">foldr</span> f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (<span class="fu">foldr</span> f acc xs)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="co">-- combining function</span>
      <span class="ot">-&gt;</span>  b            <span class="co">-- initial value</span>
      <span class="ot">-&gt;</span> [a]           <span class="co">-- list of a&#39;s</span>
      <span class="ot">-&gt;</span>  b            <span class="co">-- final value</span></code></pre>
<p>Think of folds whenever you want to reduce a <code>List</code> of &quot;things&quot; into a single &quot;thing&quot;.</p>
<p>Lets apply <code>foldr</code> step by step to see how it works.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">sum</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">sum</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> xs</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">2</span>,<span class="dv">3</span>])
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">3</span>]))
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> (<span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [])))
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span>
            <span class="fu">=</span> <span class="dv">6</span></code></pre>
</div>
<div class="section slide level1" id="foldr-1">
<h1 id="foldr-1">Foldr</h1>
<p>Like <code>map</code>, <code>fold</code> has strong properties that make it easy to reason about. Of them, a <code>fold</code>:</p>
<ul>
<li><p>always traverses each element in the collection you're folding over</p></li>
<li><p>always applies the same combining function to each element in the same way</p></li>
</ul>
<p><code>foldr</code> also has an important <em>Universal Property</em> that allows compilers to perform an optimization called <code>foldr/build</code> fusion to reduce the amount of intermediate list allocations required in code that processes lists heavily.</p>
</div>
<div class="section slide level1" id="foldr-2">
<h1 id="foldr-2">Foldr</h1>
<p>Here's an iterative factorial function</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">factorial</span>(n: Int): Int = {
    <span class="kw">var</span> res = <span class="dv">1</span>
    <span class="kw">for</span> (x &lt;- <span class="dv">1</span> until n + <span class="dv">1</span>) {
        res *= x
    }
    <span class="kw">return</span> res
}</code></pre>
<p>and the functional version using <code>foldr</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">factorial</span>(n: Int): Int = {
    (<span class="dv">1</span> until n + <span class="dv">1</span>).<span class="fu">fold</span>(<span class="dv">1</span>)(_*_)
}</code></pre>
</div>
<div class="section slide level1" id="foldr-3">
<h1 id="foldr-3">Foldr</h1>
<p>Another example</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">parseMessages</span>(msgs: List[AISMessage]) : ParseResult = {
    <span class="kw">var</span> result = <span class="kw">new</span> <span class="fu">ParseResult</span>()

    <span class="kw">for</span> (msg &lt;- msgs) {
        result += msg.<span class="fu">parse</span>()
    }
    <span class="kw">return</span> result
}</code></pre>
<p>and a functional version using <code>foldr</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">parseMessages</span>(msgs: List[AISMessage]) : ParseResult = {
    <span class="kw">var</span> result = <span class="kw">new</span> <span class="fu">ParseResult</span>()
    msgs.<span class="fu">fold</span>(result)((msg, res) =&gt; res += msg.<span class="fu">parse</span>())
}</code></pre>
</div>
<div class="section slide level1" id="foldr-4">
<h1 id="foldr-4">Foldr</h1>
<p>Many common functions are <code>foldr</code> in disguise!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">reverse</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> xs <span class="fu">++</span> [x]) [] xs
<span class="co">-- reverse = foldl (flip (:)) []</span>
<span class="co">-- foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span>

<span class="fu">maximum</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">maximum</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">foldr</span> <span class="fu">max</span> x xs

<span class="fu">concat</span><span class="ot"> ::</span> [[a]] <span class="ot">-&gt;</span> [a]
<span class="fu">concat</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">++</span>) [] xs

<span class="fu">all</span><span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">all</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">&amp;&amp;</span>) <span class="kw">True</span> xs

<span class="fu">any</span><span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">any</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">||</span>) <span class="kw">False</span> xs

<span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">filter</span> p xs <span class="fu">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="fu">:</span> xs <span class="kw">else</span> xs) [] xs

<span class="fu">map</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="fu">map</span> f xs <span class="fu">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> f x <span class="fu">:</span> xs) [] xs</code></pre>
</div>
<div class="section slide level1" id="foldr-5">
<h1 id="foldr-5">Foldr</h1>
<p>But <code>List</code> aren't the only things we can fold.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)

<span class="ot">foldTree ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b
foldTree f z (<span class="dt">Leaf</span> a)       <span class="fu">=</span> f a z
foldTree f z (<span class="dt">Branch</span> l a r) <span class="fu">=</span> f a (foldTree f (foldTree f z r) l)</code></pre>
<p>In fact, many data structures support folding operations. Haskell defines a <code>Foldable</code> typeclass.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Foldable</span> f <span class="kw">where</span>
<span class="ot">    foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> b
<span class="ot">    foldl ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> a
<span class="ot">    foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> m
    <span class="fu">...</span></code></pre>
<p>For example, <code>Maybe</code> has a <code>Foldable</code> instance.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Foldable</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    <span class="fu">foldr</span> _ z <span class="kw">Nothing</span>  <span class="fu">=</span> z
    <span class="fu">foldr</span> f z (<span class="kw">Just</span> a) <span class="fu">=</span> f a z</code></pre>
<p>You can always expect a <code>fold</code> over any foldable structure to behave like a <code>fold</code> over a <code>List</code>. We can write this as a &quot;law&quot; that says</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Foldable</span><span class="fu">.foldr</span> f z xs <span class="fu">==</span> List.foldr f z (toList xs)</code></pre>
<p>Scala doesnt directly define a <code>Foldable</code> class or trait, instead classes like <code>List</code>, <code>Map</code> and <code>Option</code> provide their own <code>foldRight</code> and <code>foldLeft</code> methods that behave just like <code>foldr</code> and <code>foldl</code>.</p>
</div>
<div class="section slide level1" id="more-recursive-primitives">
<h1 id="more-recursive-primitives">More Recursive Primitives</h1>
<p>There are many more basic recursive functions in a functional programmer's arsenal. It would be time consuming to explain them all, but here are a few examples.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]

<span class="fu">zip</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]
<span class="co">-- zip == zipWith (\a b -&gt; (a, b))</span>

<span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]

<span class="fu">iterate</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</code></pre>
</div>
<div class="section slide level1" id="intermediate-functional-concepts">
<h1 id="intermediate-functional-concepts">Intermediate Functional Concepts</h1>
<h2 id="higher-order-types">Higher Order Types</h2>
<p>First we need to understand higher order (or partially applied) types. A good analogy are generics in langauges like Java and C++. Higher order types are applied to concrete types to create new concrete types.</p>
<p>Haskell examples</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span><span class="ot">    ::</span> <span class="fu">*</span>
[]<span class="ot">     ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
[<span class="dt">Int</span>]<span class="ot">  ::</span> <span class="fu">*</span>
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="ot">(-&gt;)   ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre>
<p>Scala examples</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Int       :: *
List      :: * -&gt; *
List[Int] :: *
Option    :: * -&gt; *
Option[List[Int]] :: *
Option[List] <span class="co">// kind mis-match!</span></code></pre>
<p>The &quot;type&quot; of a type is called a kind. We say <code>Option</code> has kind <code>* -&gt; *</code>.</p>
</div>
<div class="section slide level1" id="functors">
<h1 id="functors">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
<p>A <code>Functor</code> is formally defined in category theory. Don't worry though, you'll never need to understand category theory to use <code>Functor</code>!</p>
<p>Let <span class="math"><em>C</em></span> and <span class="math"><em>D</em></span> be categories. A <code>Functor</code> from <span class="math"><em>C</em></span> to <span class="math"><em>D</em></span> is a mapping that</p>
<ul>
<li><p>associates each object <span class="math"><em>X</em> ∈ <em>C</em></span> with an object <span class="math"><em>F</em>(<em>X</em>) ∈ <em>D</em></span></p></li>
<li><p>associates each morphism <span class="math"><em>φ</em>: <em>X</em> → <em>Y</em> ∈ <em>C</em></span> with a morphism</p>
<p><span class="math"><em>F</em>(<em>φ</em>): <em>F</em>(<em>X</em>) → <em>F</em>(<em>Y</em>) ∈ <em>D</em></span></p>
<p>such that the following two conditions hold:</p>
<ul>
<li><span class="math"><em>F</em>(<em>i</em><em>d</em><sub><em>x</em></sub>) = <em>i</em><em>d</em><sub><em>F</em>(<em>X</em>)</sub></span> for all objects <span class="math"><em>X</em> ∈ <em>C</em></span></li>
<li><span class="math"><em>F</em>(<em>φ</em> ∘ <em>ψ</em>) = <em>F</em>(<em>φ</em>) ∘ <em>F</em>(<em>ψ</em>)</span> for all morphisms <span class="math"><em>φ</em>: <em>X</em> → <em>Y</em>, <em>ψ</em>: <em>Y</em> → <em>Z</em></span></li>
</ul></li>
</ul>
<p>We can write these laws in Haskell as</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">fmap</span> <span class="fu">id</span> <span class="fu">==</span> <span class="fu">id</span>
<span class="fu">fmap</span> (f <span class="fu">.</span> g) <span class="fu">==</span> <span class="fu">fmap</span> f <span class="fu">.</span> <span class="fu">fmap</span> g</code></pre>
</div>
<div class="section slide level1" id="functors-1">
<h1 id="functors-1">Functors</h1>
<p>This is a very generalized mathematical definition. In practice a programming language is only concerned with one category: the category of types representable in the language (<code>Hask</code> in Haskell).</p>
<p>In this category, objects are just the types of kind <code>*</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Maybe</span> <span class="dt">Char</span>, a</code></pre>
<p>and morphisms are just functions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>, [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>, a <span class="ot">-&gt;</span> b</code></pre>
<p>So our requirements for a <code>Functor</code> becomes</p>
<ul>
<li>associates each type <code>a</code> with a type <code>f a</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">-&gt;</span> f a</code></pre>
<ul>
<li>associates each function <code>a -&gt; b</code> with a function <code>f a -&gt; f b</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
</div>
<div class="section slide level1" id="functors-2">
<h1 id="functors-2">Functors</h1>
<p>Let take another look at the <code>Functor</code> typeclass</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
<p>The definition for the <code>Functor</code> class only defines the second requirement!</p>
<p>It seems like something is missing, until we realize the constructor for our <code>Functor</code> satisfies the first mapping, and so all is well.</p>
</div>
<div class="section slide level1" id="functors-3">
<h1 id="functors-3">Functors</h1>
<p>Here are some examples to help this sink in</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Id</span> a

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b)
    <span class="fu">fmap</span> f (<span class="dt">Id</span> a) <span class="fu">=</span> <span class="dt">Id</span> (f a)

<span class="kw">instance</span> <span class="kw">Functor</span> [] <span class="kw">where</span>
    <span class="co">-- looks very similar to map!</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> [b])
    <span class="fu">fmap</span> _ []     <span class="fu">=</span> []
    <span class="fu">fmap</span> f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> <span class="fu">fmap</span> f xs

<span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="kw">Nothing</span> <span class="fu">|</span> <span class="kw">Just</span> a

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b)
    <span class="fu">fmap</span> _ <span class="kw">Nothing</span>  <span class="fu">=</span> <span class="kw">Nothing</span>
    <span class="fu">fmap</span> f (<span class="kw">Just</span> a) <span class="fu">=</span> <span class="kw">Just</span> (f a)

<span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="kw">Left</span> a <span class="fu">|</span> <span class="kw">Right</span> b

<span class="kw">instance</span> <span class="kw">Functor</span> (<span class="dt">Either</span> a) <span class="kw">where</span>
    <span class="fu">fmap</span> _ (<span class="kw">Left</span>  a) <span class="fu">=</span> <span class="kw">Left</span> a
    <span class="fu">fmap</span> f (<span class="kw">Right</span> b) <span class="fu">=</span> <span class="kw">Right</span> (f b)

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> b)
    <span class="fu">fmap</span> f (<span class="dt">Leaf</span> a)     <span class="fu">=</span> <span class="dt">Leaf</span> (f a)
    <span class="fu">fmap</span> f (<span class="dt">Branch</span> l r) <span class="fu">=</span> <span class="dt">Branch</span> (<span class="fu">fmap</span> f l) (f a) (<span class="fu">fmap</span> f r)</code></pre>
<p>In a language with <code>Future</code>, we can make <code>Future</code> an instance of <code>Functor</code>. How would <code>fmap</code> behave?</p>
</div>
<div class="section slide level1" id="functors-4">
<h1 id="functors-4">Functors</h1>
<p>We can think of a <code>Functor</code> as some kind of &quot;context&quot; around a pure value. We use <code>fmap</code> to lift a function on pure values to a function on values in this &quot;context&quot;, and <code>fmap</code> automagically knows what instance of <code>Functor</code> to use!</p>
<p>Scala by default doesn't define <code>Functor</code>, instead classes like <code>List</code>, <code>Map</code> and <code>Option</code> define their own <code>map</code> methods that &quot;do the right thing&quot;. These are exactly the same as their would-be <code>Functor</code> instances.</p>
</div>
<div class="section slide level1" id="functors-5">
<h1 id="functors-5">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="functors-6">
<h1 id="functors-6">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="functors-7">
<h1 id="functors-7">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="functors-8">
<h1 id="functors-8">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="dt">Pure</span> (f r)</code></pre>
</div>
<div class="section slide level1" id="monads">
<h1 id="monads">Monads</h1>
<blockquote>
<p>&quot;A monad is just a monoid in the category of endofunctors, what's the problem?&quot;</p>
</blockquote>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a

<span class="ot">    join ::</span> m (m a) <span class="ot">-&gt;</span> m a
    join mm <span class="fu">=</span> mm <span class="fu">&gt;&gt;=</span> <span class="fu">id</span>

<span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
    m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> join (<span class="fu">fmap</span> f m)</code></pre>
<p>We can see from the definition that a <code>Monad</code> must also be a <code>Functor</code>. Indeed, a <code>Monad</code> is strictly more powerful than a <code>Functor</code> because we can derive a <code>Functor</code> instance from any <code>Monad</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (m a <span class="ot">-&gt;</span> m b)
<span class="fu">fmap</span> f m <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="fu">return</span> (f a)</code></pre>
</div>
<div class="section slide level1" id="monads-1">
<h1 id="monads-1">Monads</h1>
<p><code>Monads</code> are also formally defined in category theory:</p>
<p>Let <span class="math"><em>C</em></span> be a category. A <code>Monad</code> on <span class="math"><em>C</em></span> consists of a (endo)functor <span class="math"><em>T</em>: <em>C</em> → <em>C</em></span>, together with two natural transformations</p>
<p><span class="math"><em>u</em><em>n</em><em>i</em><em>t</em>: <em>X</em> → <em>T</em>(<em>X</em>)</span> and <span class="math"><em>j</em><em>o</em><em>i</em><em>n</em>: <em>T</em>(<em>T</em>(<em>X</em>)) → <em>T</em>(<em>X</em>)</span></p>
<p>such that the following two conditions hold:</p>
<ul>
<li><span class="math"><em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>T</em>(<em>j</em><em>o</em><em>i</em><em>n</em>) = <em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>j</em><em>o</em><em>i</em><em>n</em></span></li>
<li><span class="math"><em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>u</em><em>n</em><em>i</em><em>t</em> = <em>i</em><em>d</em> = <em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>T</em>(<em>u</em><em>n</em><em>i</em><em>t</em>)</span></li>
</ul>
<p>The formal definition uses <code>join</code>, but the more useful operation in practice is <code>(&gt;&gt;=)</code>, pronounced &quot;bind&quot;. In terms of <code>(&gt;&gt;=)</code> these laws become</p>
<p>Left Identity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">return</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">==</span> f a</code></pre>
<p>Right Identity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">==</span> m</code></pre>
<p>Associativity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g <span class="fu">==</span> m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)
<span class="co">-- (m &gt;&gt;= f) &gt;&gt;= g == m &gt;&gt;= (f &gt;=&gt; g)</span></code></pre>
</div>
<div class="section slide level1" id="monads-2">
<h1 id="monads-2">Monads</h1>
<p>To make a <code>Monad</code> instance, we need two things</p>
<ul>
<li><p>a function to create a monadic action that does nothing but return a value</p></li>
<li><p>a function to apply a monadic function to the result of a monadic action</p></li>
</ul>
<p>Some example <code>Monad</code> instances</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Id</span> a
    join (<span class="dt">Id</span> (<span class="dt">Id</span> a)) <span class="fu">=</span> <span class="dt">Id</span> a

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> <span class="dt">Identity</span> b
    <span class="dt">Id</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">List</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> [a]
    join xs <span class="fu">=</span> <span class="fu">concat</span> xs

<span class="ot">    (&gt;&gt;=) ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [b]
    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">concat</span> (<span class="fu">map</span> f xs)

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="kw">Just</span> a

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
    <span class="kw">Nothing</span> <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Nothing</span>
    <span class="kw">Just</span> a  <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a

<span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">Either</span> a) <span class="kw">where</span>
    <span class="fu">return</span> b <span class="fu">=</span> <span class="kw">Right</span> b

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a c
    <span class="kw">Left</span>  a <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Left</span> a
    <span class="kw">Right</span> b <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f b

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Tree</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Tree</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> b
    <span class="dt">Leaf</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a
    <span class="dt">Branch</span> l r <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Branch</span> (l <span class="fu">&gt;&gt;=</span> f) (r <span class="fu">&gt;&gt;=</span> f)</code></pre>
</div>
<div class="section slide level1" id="monads-3">
<h1 id="monads-3">Monads</h1>
<p>Again, Scala by default doesnt define <code>Monad</code>, instead classes like <code>List</code>, <code>Map</code> and <code>Option</code> define their own <code>flatMap</code> methods. These <code>flatMap</code> methods behave exactly like <code>(&gt;&gt;=)</code>.</p>
<p>Scala does provide some nice syntactic sugar for monadic operations that is very similar to do notation in Haskell.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- List(<span class="dv">1</span>, <span class="dv">2</span>)
    y &lt;- List(<span class="dv">3</span>, <span class="dv">4</span>)
    z = (x, y)
} <span class="kw">yield</span> z
<span class="co">// List((1,3), (1,4), (2,3), (2,4))</span></code></pre>
<p>This desugars to nested <code>flatMap</code>s</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List(<span class="dv">1</span>,<span class="dv">2</span>).<span class="fu">flatMap</span>(x =&gt; List(<span class="dv">3</span>,<span class="dv">4</span>).<span class="fu">flatMap</span>(y =&gt; List((x, y))))</code></pre>
<p>This is a good example of the monadic effect of <code>List</code>, non-determinism! Think of the <code>List</code> <code>Monad</code> as a computation that doesnt know what its result might be, instead of operating on just one result, you operate on all possible results.</p>
<p>Here is a interesting example of non-determinism in the <code>List</code> <code>Monad</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterM ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
<span class="ot">powerset ::</span> [a] <span class="ot">-&gt;</span> [[a]]
powerset xs <span class="fu">=</span> filterM (<span class="fu">const</span> [<span class="kw">True</span>, <span class="kw">False</span>]) xs
<span class="co">-- powerset [1,2,3] = [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]</span></code></pre>
</div>
<div class="section slide level1" id="monads-4">
<h1 id="monads-4">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-5">
<h1 id="monads-5">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next    <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-6">
<h1 id="monads-6">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-7">
<h1 id="monads-7">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-8">
<h1 id="monads-8">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r</code></pre>
</div>
<div class="section slide level1" id="monads-9">
<h1 id="monads-9">Monads</h1>
<p><code>Option</code> is a very useful abstraction that saves us from the dreaded <code>NullPointerException</code>. With <code>Option</code>, we can tell the compiler &quot;this computation might fail to return a result&quot;, and the compiler will make sure that we always handle the failure case. If we don't, the code won't compile!</p>
<h2 id="section">1</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- None
    z = x + y
} <span class="kw">yield</span> z</code></pre>
<h2 id="section-1">2</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- Some(<span class="dv">5</span>)
    z = x + y
} <span class="kw">yield</span> z</code></pre>
</div>
<div class="section slide level1" id="monads-10">
<h1 id="monads-10">Monads</h1>
<p><code>Option</code> is a very useful abstraction that saves us from the dreaded <code>NullPointerException</code>. With <code>Option</code>, we can tell the compiler &quot;this computation might fail to return a result&quot;, and the compiler will make sure that we always handle the failure case. If we don't, the code won't compile!</p>
<h2 id="section-2">1</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- None
    z = x + y
} <span class="kw">yield</span> z
<span class="co">// None</span></code></pre>
<h2 id="section-3">2</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- Some(<span class="dv">5</span>)
    z = x + y
} <span class="kw">yield</span> z
<span class="co">// Some(9)</span></code></pre>
</div>
<div class="section slide level1" id="monads-11">
<h1 id="monads-11">Monads</h1>
<p>The <code>Option</code> <code>Monad</code> represents a computation that could possibly fail to return a result at one or more points. If any subcomputation returns <code>Nothing</code>, the entire computation should return <code>Nothing</code>.</p>
<p>You may consider using <code>Option</code> instead of <code>try/catch</code> blocks. Instead of throwing an exception if a computation fails (ex. establishing a database connection), return <code>None</code> instead and let the calling function decide how to handle the failure.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">bothGrandFathers</span>(person: Person): Option[(Person, Person)] =
    person.<span class="fu">getFather</span>() <span class="kw">match</span> {
        <span class="kw">case</span> None =&gt; None
        <span class="kw">case</span> Some(father) =&gt; father.<span class="fu">getFather</span>() <span class="kw">match</span> {
          <span class="kw">case</span> None =&gt; None
          <span class="kw">case</span> Some(grandFather1) =&gt; person.<span class="fu">getMother</span>() <span class="kw">match</span> {
            <span class="kw">case</span> None =&gt; None
            <span class="kw">case</span> Some(mother) =&gt; mother.<span class="fu">getFather</span>() <span class="kw">match</span> {
              <span class="kw">case</span> None =&gt; None
              <span class="kw">case</span> Some(grandFather1) =&gt;
                Some((grandFather1, grandFather2))
            }
          }
        }
}</code></pre>
</div>
<div class="section slide level1" id="monads-12">
<h1 id="monads-12">Monads</h1>
<p>A much more readable version using the <code>Option</code> <code>Monad</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">bothGrandFathers</span>(person: Person): Option[(Person, Person)] = <span class="kw">for</span> {
  father       &lt;- person.<span class="fu">getFather</span>()
  grandFather1 &lt;- father.<span class="fu">getFather</span>()
  mother       &lt;- person.<span class="fu">getMother</span>()
  grandFather2 &lt;- mother.<span class="fu">getFather</span>()
} <span class="kw">yield</span> (grandFather1, grandFather2)</code></pre>
</div>
<div class="section slide level1" id="arcfilter">
<h1 id="arcfilter">ARCFilter</h1>
<p>ARCFilter is an important component of the ARC project that makes use of <code>Monad</code>s. Some background:</p>
<ul>
<li><p>We'd like to be able to run a series of processing and filtering utilities on our AIS data as it passes through ARC. ie. IMF, PV, other</p></li>
<li><p>Each component receives some input, processes it and outputs to the next process.</p></li>
<li><p>Might call outside code (IMF C++ code, PVDaemon) that could throw an error, hang on a database connection or any other nasty real world exceptions that we'd like to be able to protect ourselves from.</p></li>
<li><p>Should be simple, flexible and allow new components to be easily added to any given processing pipeline.</p></li>
</ul>
</div>
<div class="section slide level1" id="arcfilter-1">
<h1 id="arcfilter-1">ARCFilter</h1>
<p>So, lets think about how we'd go about implementing this. We need to be able to compose these filters together, such that the output of one becomes the input of the next filter in the chain.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
f <span class="fu">.</span> g <span class="fu">=</span> \a <span class="ot">-&gt;</span> f (g a)</code></pre>
<p>Since this is a talk on functional programming, lets try modeling it as a function! We already know functions compose nicely, with the behaviour we want.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilter[A, B] {
    <span class="kw">def</span> <span class="fu">apply</span>(x: A): B
}</code></pre>
<p>This is nice, but...</p>
</div>
<div class="section slide level1" id="arcfilter-2">
<h1 id="arcfilter-2">ARCFilter</h1>
<p>The type signature of our apply method says &quot;for any A you give me, I'll always give you a B in return&quot;. But our filters have to deal with exceptions, misbehaving external code or other nasty things, so we'd like to give these filters the ability to either succeed in processing some data or fail with an error.</p>
<p>Luckily, the Scala standard library includes <code>Try</code> which does exactly that. <code>Try</code> is a trait that is subclassed by <code>Success</code> and <code>Failure</code>.</p>
<p>Its essentially <code>Either</code>, just with some additional semantics attached to <code>Left</code> and <code>Right</code>. Alternatively, its like <code>Option</code> but with additional information about the error stuffed inside the <code>None</code> case.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilter[A, B] {
    <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[B]
}</code></pre>
<p>An example using <code>Try</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onlyEven</span>(x: Int): Try[Int] =
    <span class="kw">if</span> (x % <span class="dv">2</span> == <span class="dv">0</span>) <span class="fu">Success</span>(x)
    <span class="kw">else</span> <span class="fu">Failure</span>(<span class="kw">new</span> Exception(<span class="st">&quot;not even!&quot;</span>))</code></pre>
</div>
<div class="section slide level1" id="arcfilter-3">
<h1 id="arcfilter-3">ARCFilter</h1>
<p>Now, <code>Try</code> is a <code>Monad</code>. We're not going to worry about that just yet, but we are going to use its <code>flatMap</code> method, which is a monadic bind, to give us the ability to compose <code>ARCFilter</code>s together.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilter[A, B] { self =&gt;
    <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[B]

    <span class="kw">def</span> pipeTo[C](next: ARCFilter[B, C]): ARCFilter[A, C] = {
        <span class="kw">new</span> ARCFilter[A, C] = {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[C] = {
                <span class="fu">self</span>(x) flatMap next.<span class="fu">apply</span>
            }
        }
    }
}</code></pre>
</div>
<div class="section slide level1" id="arcfilter-4">
<h1 id="arcfilter-4">ARCFilter</h1>
<p>Let's see how this all works so far:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">
<span class="kw">case</span> <span class="kw">object</span> NotEven <span class="kw">extends</span> Exception
<span class="kw">case</span> <span class="kw">object</span> NotLessThanTen <span class="kw">extends</span> Exception

<span class="kw">val</span> onlyEvens = <span class="kw">new</span> ARCFilter[Int, Int] = {
    <span class="kw">def</span> <span class="fu">apply</span>(x: Int): Try[Int] = {
        <span class="kw">if</span> (x % <span class="dv">2</span> == <span class="dv">0</span>) <span class="fu">Success</span>(x)
        <span class="kw">else</span> <span class="fu">Failure</span>(NotEven)
    }
}

<span class="kw">val</span> lessThanTen = <span class="kw">new</span> ARCFilter[Int, Int] = {
    <span class="kw">def</span> <span class="fu">apply</span>(x: Int): Try[Int] = {
        <span class="kw">if</span> (x &lt; <span class="dv">10</span>) <span class="fu">Success</span>(x)
        <span class="kw">else</span> <span class="fu">Failure</span>(NotLessThanTen)
    }
}

<span class="kw">val</span> combined = onlyEvens.<span class="fu">pipeTo</span>(lessThanTen)
<span class="fu">combined</span>(<span class="dv">3</span>)  <span class="co">// Failure(NotEven)</span>
<span class="fu">combined</span>(<span class="dv">12</span>) <span class="co">// Failure(NotLessThanTen)</span>
<span class="fu">combined</span>(<span class="dv">8</span>)  <span class="co">// Success(8)</span></code></pre>
</div>
<div class="section slide level1" id="arcfilter-5">
<h1 id="arcfilter-5">ARCFilter</h1>
<p>As an added bonus, the type of <code>pipeTo</code> guarantees that <code>ARCFilter</code>s are composed correctly.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> bad = <span class="kw">new</span> ARCFilter[Boolean, Char] = {
    <span class="kw">def</span> <span class="fu">apply</span>(x: Boolean): Try[Char] = {
        <span class="kw">if</span> (x) <span class="fu">Success</span>(<span class="st">&quot;t&quot;</span>)
        <span class="kw">else</span> <span class="fu">Failure</span>(<span class="st">&quot;f&quot;</span>)
    }
}

bad.<span class="fu">pipeTo</span>(onlyEvens) <span class="co">// won&#39;t compile!</span></code></pre>
</div>
<div class="section slide level1" id="arcfilter-6">
<h1 id="arcfilter-6">ARCFilter</h1>
<p>In fact, <code>ARCFilter</code> is a monad. Here is its <code>flatMap</code> method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilter[A, B] { self =&gt;
    <span class="kw">def</span> <span class="fu">flatMap</span>(f: B =&gt; ARCFilter[A, C]): ARCFilter[A, C] = {
        <span class="kw">new</span> ARCFilter[A, C] {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[C] = {
                <span class="fu">self</span>(x) flatMap { b: B =&gt; <span class="fu">f</span>(b).<span class="fu">apply</span>(x) }
            }
        }
    }
}</code></pre>
<p><code>ARCFilter</code> forms what is known as a <code>Kleisli</code> arrow. Simplified, a <code>Kleisli</code> arrow is a function from pure values to monadic values, or in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Kleisli</span> m a b <span class="fu">=</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m b</code></pre>
<p><code>Kleisli</code> gives us a way to compose functions that return <code>Monad</code>s.</p>
<p>Our <code>pipeTo</code> function is simply composition in the <code>Kleisli</code> category.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Category</span> (<span class="ot">cat ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    id  ::</span> cat a a
<span class="ot">    (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</code></pre>
</div>
<div class="section slide level1" id="arcfilter-7">
<h1 id="arcfilter-7">ARCFilter</h1>
<p>Let's take a look at the full definition for <code>ARCFilter</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilter[A, B] { self =&gt;
    <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[B]

    <span class="kw">def</span> pipeTo[C](next: ARCFilter[B, C]): ARCFilter[A, C] = {
        <span class="kw">new</span> ARCFilter[A, C] = {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[C] = {
                <span class="fu">self</span>(x) flatMap next.<span class="fu">apply</span>
            }
        }
    }

    <span class="kw">def</span> <span class="fu">flatMap</span>(f: B =&gt; ARCFilter[A, C]): ARCFilter[A, C] = {
        <span class="kw">new</span> ARCFilter[A, C] {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[C] = {
                <span class="fu">self</span>(x) flatMap { b: B =&gt; <span class="fu">f</span>(b).<span class="fu">apply</span>(x) }
            }
        }
    }
}</code></pre>
<p>Note that we never use anything specific to <code>Try</code>: we never pattern match, call methods specific to <code>Try</code> or or otherwise use the knowledge that we're dealing with <code>Try</code>. In fact, the only method of <code>Try</code> that we ever use is <code>flatMap</code>, which we know to be the monadic bind.</p>
</div>
<div class="section slide level1" id="arcfilter-8">
<h1 id="arcfilter-8">ARCFilter</h1>
<p><code>Try</code> gives our <code>ARCFilter</code> error handling abilities, but suppose we wanted some other ability instead. For example, for an <code>ARCFilter</code> to return multiple outputs. Well, <code>List</code> gives us this ability, so we could write:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilterList[A, B] { self =&gt;
    <span class="kw">def</span> <span class="fu">apply</span>(x: A): List[B]

    <span class="kw">def</span> pipeTo[C](next: ARCFilterList[B, C]): ARCFilterList[A, C] = {
        <span class="kw">new</span> ARCFilterList[A, C] = {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): List[C] = {
                <span class="fu">self</span>(x) flatMap next.<span class="fu">apply</span>
            }
        }
    }

    <span class="kw">def</span> <span class="fu">flatMap</span>(f: B =&gt; ARCFilterList[A, C]): ARCFilterList[A, C] = {
        <span class="kw">new</span> ARCFilterList[A, C] {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): List[C] = {
                <span class="fu">self</span>(x) flatMap { b: B =&gt; <span class="fu">f</span>(b).<span class="fu">apply</span>(x) }
            }
        }
    }
}</code></pre>
<p>This is exactly the same as <code>ARCFilter</code>, we've just replaced <code>Try</code> with <code>List</code>, and given it a new name. That's a lot of redundant code! Again, we never use the knowledge we're working with <code>List</code>, just the <code>flatMap</code> method.</p>
</div>
<div class="section slide level1" id="arcfilter-9">
<h1 id="arcfilter-9">ARCFilter</h1>
<p>Here's an example of the new <code>ARCFilterList</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> factors = <span class="kw">new</span> ARCFilterList[Int, Int] = {
    <span class="kw">def</span> <span class="fu">apply</span>(x: Int): List[Int] = <span class="fu">factor</span>(x)
}

<span class="kw">val</span> totient = <span class="kw">new</span> ARCFilterList[Int, Int] = {
    <span class="kw">def</span> <span class="fu">apply</span>(x: Int): List[Int] = <span class="fu">phi</span>(x)
}

<span class="fu">factors</span>(<span class="dv">6</span>) <span class="co">// List(1, 2, 3)</span>
<span class="fu">totient</span>(<span class="dv">1</span>) <span class="co">// List(1)</span>
<span class="fu">totient</span>(<span class="dv">2</span>) <span class="co">// List(1)</span>
<span class="fu">totient</span>(<span class="dv">3</span>) <span class="co">// List(1, 2)</span>

<span class="kw">val</span> combined = factors.<span class="fu">pipeTo</span>(totient)

<span class="fu">combined</span>(<span class="dv">6</span>) <span class="co">// List(1, 1, 1, 2)</span></code></pre>
</div>
<div class="section slide level1" id="arcfilter-10">
<h1 id="arcfilter-10">ARCFilter</h1>
<p>We'd like to reduce the code duplication here. We don't really need to know what type of output we're dealing with, so long as it has a <code>flatMap</code> method. It would be nice to be able to write:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ARCFilter[M[_], A, B] { self =&gt;
    <span class="kw">def</span> <span class="fu">apply</span>(x: A): M[B]

    <span class="kw">def</span> pipeTo[C](next: ARCFilter[M[_], B, C]): ARCFilter[M[_], A, C] = {
        <span class="kw">new</span> ARCFilter[M[_], A, C] = {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): M[C] = {
                <span class="fu">self</span>(x) flatMap next.<span class="fu">apply</span>
            }
        }
    }

    <span class="kw">def</span> <span class="fu">flatMap</span>(f: B =&gt; ARCFilter[M[_], A, C]): ARCFilter[M[_], A, C] = {
        <span class="kw">new</span> ARCFilter[M[_], A, C] {
            <span class="kw">def</span> <span class="fu">apply</span>(x: A): M[C] = {
                <span class="fu">self</span>(x) flatMap { b: B =&gt; <span class="fu">f</span>(b).<span class="fu">apply</span>(x) }
            }
        }
    }
}</code></pre>
<p>Unfortunately, Scala won't let us write that, as the compiler can't prove that whatever <code>M</code> is provides a <code>flatMap</code> method.</p>
</div>
<div class="section slide level1" id="arcfilter-11">
<h1 id="arcfilter-11">ARCFilter</h1>
<p>We've arrived at the motivation for the <code>Monad</code> typeclass.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Function</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> m <span class="kw">where</span>
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre>
<p>If Scala had some support for typeclasses (it can in theory, but you must go through a great deal of blood, sweat and implicit higher-order traits in order to achieve the same effects. See scalaz) we could write <code>ARCFilter</code> the way we desire.</p>
<p><code>Monad</code> is simply an interface that provides two functions <code>return</code> and <code>(&gt;&gt;=)</code>/<code>flatMap</code>. Its most commonly used to reduce the code duplication we saw above in <code>ARCFilter</code>/<code>ARCFilterList</code></p>
</div>
<div class="section slide level1" id="arcfilter-12">
<h1 id="arcfilter-12">ARCFilter</h1>
<p>We can compose <code>ARCFilter</code>s by hand, but it'd be nice to be able to compose an arbitrary number of filters. Something along the lines of</p>
<pre class="sourceCode scala"><code class="sourceCode scala">buildMany[C, D ... <span class="fu">N</span>](fst: ARCFilter[B, C], snd: ARCFilter[C, D] ...): ARCFilter[A, N]</code></pre>
<p>but this is impractical. Because Scala is strongly typed, we'd need to know the types of every filter we want to compose in advance. Fortunately we can still achieve our original goal, just modified slightly.</p>
</div>
<div class="section slide level1" id="arcfilter-13">
<h1 id="arcfilter-13">ARCFilter</h1>
<p>If we restrict our filters to type <code>ARCFilter[A, A]</code>, that is, the output and input have the same type, then we have whats known as a <code>Monoid</code>. A <code>Monoid</code> is essentially a group, with an associative binary operation and an identity element.</p>
<p>We can define the identity filter as a filter that always succeeds and does no work on its input and we've already defined our associative binary operation.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> ARCFilter {
    <span class="kw">def</span> Identity[A] = <span class="kw">new</span> ARCFilter[A, A] {
        <span class="kw">def</span> <span class="fu">apply</span>(x: A): Try[A] = <span class="fu">Success</span>(x)
    }
}</code></pre>
<p>Now we can define an interface for building pipelines</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> PipelineBuilder[A] {
    <span class="kw">def</span> <span class="fu">build</span>(xs: Seq[ARCFilter[A, A]): ARCFilter[A, A] = {
        xs.<span class="fu">foldLeft</span>(ARCFilter.<span class="fu">Identitiy</span>[A]) {
            <span class="kw">case</span> (z, x) =&gt; z.<span class="fu">pipeTo</span>(x)
        }
    }
}</code></pre>
</div>
<div class="section slide level1" id="arcfilter-14">
<h1 id="arcfilter-14">ARCFilter</h1>
<p><code>Monads</code> are not some just some abstract category theory nonsense, they are simply a common design pattern of sequencing effects that has been abstracted into a functional interface.</p>
<p>Other <code>Monad</code>s can provide effects such as</p>
<ul>
<li><p>read-only/write-only state</p></li>
<li><p>read/write state</p></li>
<li><p>continuations</p></li>
<li><p>parallelism/concurrency</p></li>
<li><p>Software Transactional Memory</p></li>
<li><p>I/O effects</p></li>
<li><p>streaming resources</p></li>
<li><p>Domain Specific Languages</p></li>
</ul>
</div>
<div class="section slide level1" id="monad-transformers">
<h1 id="monad-transformers">Monad Transformers</h1>
<p>The real power of <code>Monad</code>s comes from their composability. You can choose which side-effects you want to allow your computations access to (alternatively, what side-effects you DON'T want them to have access to).</p>
<p>The compiler ensures you don't accidently use any side-effects that you haven't explicitly mentioned, which helps reduce programming errors.</p>
<p>To layer <code>Monad</code>s on top of one another, we'll need <code>MonadTrans</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    lift ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre>
<p>which satisfies these laws</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">lift (<span class="fu">return</span> x) <span class="fu">==</span> <span class="fu">return</span> x
lift (m <span class="fu">&gt;&gt;=</span> f)  <span class="fu">==</span> (lift m) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> lift (f x))</code></pre>
<p>Whoa, that kind signature looks pretty scary!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="co">-- a Monad</span>
  <span class="ot">-&gt;</span> <span class="fu">*</span>        <span class="co">-- a concrete type</span>
  <span class="ot">-&gt;</span> <span class="fu">*</span>        <span class="co">-- we get a concrete type back</span></code></pre>
</div>
<div class="section slide level1" id="monad-transformers-1">
<h1 id="monad-transformers-1">Monad Transformers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> m r
    <span class="fu">=</span> <span class="dt">Yield</span>   (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Fork</span>    (<span class="dt">Thread</span> m r) (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Lift</span> (m (<span class="dt">Thread</span> m r))
    <span class="fu">|</span> <span class="dt">Pure</span>  r
    <span class="fu">|</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Functor</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Lift</span> m)          <span class="fu">=</span> <span class="dt">Lift</span> (liftM (<span class="fu">fmap</span> f) m)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="dt">Pure</span> (f r)
    <span class="fu">fmap</span> f  <span class="dt">Done</span>             <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Pure</span> a

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Lift</span> m          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Lift</span> (m <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r
    <span class="dt">Done</span>            <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">Thread</span> a) <span class="kw">where</span>
    lift m <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monad-transformers-2">
<h1 id="monad-transformers-2">Monad Transformers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> m r
    <span class="fu">=</span> <span class="dt">Yield</span>   (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Fork</span>    (<span class="dt">Thread</span> m r) (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Lift</span> (m (<span class="dt">Thread</span> m r))
    <span class="fu">|</span> <span class="dt">Pure</span>  r
    <span class="fu">|</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Functor</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Lift</span> m)          <span class="fu">=</span> <span class="dt">Lift</span> (liftM (<span class="fu">fmap</span> f) m)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="dt">Pure</span> (f r)
    <span class="fu">fmap</span> f  <span class="dt">Done</span>             <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Pure</span> a

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Lift</span> m          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Lift</span> (m <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r
    <span class="dt">Done</span>            <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">Thread</span> a) <span class="kw">where</span>
    lift m <span class="fu">=</span> <span class="dt">Lift</span> (liftM <span class="dt">Pure</span> m)</code></pre>
</div>
<div class="section slide level1" id="monad-transformers-3">
<h1 id="monad-transformers-3">Monad Transformers</h1>
<p>In the few lines of code in the last slide, we've created a fully usable co-operative thread DSL. All we need are a few smart constructors.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">yield ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m ()
yield <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Pure</span> ())

<span class="ot">done ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m r
done <span class="fu">=</span> <span class="dt">Done</span>

<span class="ot">fork ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m r <span class="ot">-&gt;</span> <span class="dt">Thread</span> m ()
fork thread <span class="fu">=</span> <span class="kw">do</span>
    child <span class="ot">&lt;-</span> <span class="dt">Fork</span> (<span class="dt">Pure</span> <span class="kw">False</span>) (<span class="dt">Pure</span> <span class="kw">True</span>)
    when child <span class="fu">$</span> thread <span class="fu">&gt;&gt;</span> done</code></pre>
<p>and a roundRobin thread scheduler</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">roundRobin ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m a <span class="ot">-&gt;</span> m ()
roundRobin t0 <span class="fu">=</span> go (singleton t0)
  <span class="kw">where</span>
    go ts <span class="fu">=</span> <span class="kw">case</span> viewl ts <span class="kw">of</span>
        <span class="co">-- The queue is empty: we&#39;re done!</span>
        <span class="dt">EmptyL</span>   <span class="ot">-&gt;</span> <span class="fu">return</span> ()
        <span class="co">-- The queue is non-empty: Process the first thread</span>
        t <span class="fu">:&lt;</span> ts <span class="ot">-&gt;</span> <span class="kw">case</span> t <span class="kw">of</span>
            <span class="co">-- Yielding threads go to the back of the queue</span>
            <span class="dt">Yield</span>   t&#39; <span class="ot">-&gt;</span> go (ts <span class="fu">|&gt;</span> t&#39;)
            <span class="co">-- New threads go to the back of the queue</span>
            <span class="dt">Fork</span> t1 t2 <span class="ot">-&gt;</span> go (t1 <span class="fu">&lt;|</span> (ts <span class="fu">|&gt;</span> t2))
            <span class="co">-- Run effects in the base monad</span>
            <span class="dt">Lift</span>    m  <span class="ot">-&gt;</span> m <span class="fu">&gt;&gt;=</span> \t&#39; <span class="ot">-&gt;</span> go (t&#39; <span class="fu">&lt;|</span> ts)
            <span class="co">-- Thread done: Remove the thread from the queue</span>
            _          <span class="ot">-&gt;</span> go ts</code></pre>
</div>
<div class="section slide level1" id="monad-transformers-4">
<h1 id="monad-transformers-4">Monad Transformers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mainThread ::</span> <span class="dt">Thread</span> <span class="dt">IO</span> ()
mainThread <span class="fu">=</span> <span class="kw">do</span>
    lift <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Forking thread #1&quot;</span>
    fork thread1
    lift <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Forking thread #2&quot;</span>
    fork thread2

<span class="ot">thread1 ::</span> <span class="dt">Thread</span> <span class="dt">IO</span> ()
thread1 <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span>
    lift <span class="fu">$</span> <span class="fu">print</span> i
    yield

<span class="ot">thread2 ::</span> <span class="dt">Thread</span> <span class="dt">IO</span> ()
thread2 <span class="fu">=</span> replicateM_ <span class="dv">3</span> <span class="fu">$</span> <span class="kw">do</span>
    lift <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Hello World&quot;</span>
    yield</code></pre>
<p>Now if we run our <code>mainThread</code> using <code>roundRobin</code> we'll see</p>
<pre><code>Forking thread #1
Forking thread #2
1
Hello World
2
Hello World
3
Hello World
4
5
6
7
8
9
10</code></pre>
<p>We've used our <code>Thread</code> transformer to layer <code>IO</code> effects (printing to stdout in this case) with our threading effects.</p>
</div>
</body>
</html>
