<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="section slide level1" id="what-is-functional-programming">
<h1 id="what-is-functional-programming">What is Functional Programming?</h1>
<p>Functional programming is a style of programming that encourages</p>
<ul>
<li><p>pure functions: &quot;mathematical&quot; functions that depend only on their inputs, not the global program/world state.</p></li>
<li><p>immutable data structures: once defined, data cannot be mutated. Instead, a new modified copy of the data is created.</p></li>
<li><p>declarative style: describe &quot;what&quot; the solution to a problem is, not &quot;how&quot; to do it.</p></li>
<li><p>implicit recursion: recursion is used instead of iteration, but higher order functions (functions that take functions as arguments to change their behaviour) abstract explicit recursion away.</p></li>
</ul>
</div>
<div class="section slide level1" id="why-use-functional-programming">
<h1 id="why-use-functional-programming">Why Use Functional Programming?</h1>
<p>Correct use of a functional style results in code that is easier to maintain and reason about.</p>
<p>Functional code is often &quot;obviously&quot; correct and very composable and reusable due to the use of higher order functions.</p>
<p>Pure functions and immutable data structures reduce the cognitive load required to understand a piece of code. The behaviour of a function will never depend on a global variable defined halfway across the code base, or the current state of the program. Everything a programmer needs to reason about a piece of code is self contained.</p>
<p>All the code we will ever write will eventually be executed on some inherently procedural CPU. However, our code will also have to be modified many times over by other programmers to add new features, fix bugs and optimize for performance.</p>
<p>Functional programming lets us write clear, correct code that is easy to maintain, while letting powerful optimizing compilers do the &quot;busy work&quot; of translating our high level code for humans to low level code for machines.</p>
</div>
<div class="section slide level1" id="haskell-at-a-glance">
<h1 id="haskell-at-a-glance">Haskell at a Glance</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> <span class="dt">List</span> a
<span class="co">-- []  :: List a</span>
<span class="co">-- (:) :: a -&gt; List a -&gt; List a</span>

<span class="ot">myList ::</span> [<span class="dt">Int</span>]
myList <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span> <span class="fu">:</span> (<span class="dv">3</span> <span class="fu">:</span> []))
<span class="co">-- or myList = [1, 2, 3]</span>
<span class="co">-- or myList = [1..3]</span>

<span class="co">-- pattern matching</span>
<span class="fu">null</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">null</span> []     <span class="fu">=</span> <span class="kw">True</span>
<span class="fu">null</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">False</span>

<span class="co">-- curried function</span>
<span class="ot">add3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add3 x y z <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">+</span> z

<span class="co">-- partially applied function</span>
<span class="ot">add2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add2 <span class="fu">=</span> add3 <span class="dv">0</span>

<span class="co">-- wildcards</span>
<span class="fu">const</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
<span class="fu">const</span> x _ <span class="fu">=</span> x</code></pre>
</div>
<div class="section slide level1" id="essential-higher-order-functions">
<h1 id="essential-higher-order-functions">Essential Higher Order Functions</h1>
<p>There are some very frequently used higher order functions that capture common recursive operations over <code>List</code>. We'll see later that most of these functions can be generalized to work on other data structures besides <code>List</code>.</p>
<h2 id="map">Map</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="fu">map</span> _ []     <span class="fu">=</span> []
<span class="fu">map</span> f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> <span class="fu">map</span> f xs</code></pre>
<p>Let's apply <code>map</code> step by step to see how it works.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span> <span class="fu">odd</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">map</span> <span class="fu">odd</span> [<span class="dv">2</span>,<span class="dv">3</span>]
                <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">2</span> <span class="fu">:</span> <span class="fu">map</span> <span class="fu">odd</span> [<span class="dv">3</span>]
                <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">2</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">3</span> <span class="fu">:</span> <span class="fu">map</span> <span class="fu">odd</span> []
                <span class="fu">=</span> <span class="fu">odd</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">2</span> <span class="fu">:</span> <span class="fu">odd</span> <span class="dv">3</span> <span class="fu">:</span> []
                <span class="fu">=</span> [<span class="kw">True</span>, <span class="kw">False</span>, <span class="kw">True</span>]</code></pre>
<p>Basically, <code>map</code> returns a new <code>List</code> where each element in the input <code>List</code> has been replaced with the result of applying the function to that element.</p>
</div>
<div class="section slide level1" id="map-1">
<h1 id="map-1">Map</h1>
<p>Suppose we have a <code>List</code> of input data. We want to process each item in some way and store the results in a new <code>List</code>. We might do this using the following imperative code.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">processList</span>(input: List[Input]) : List[Output] = {
    <span class="kw">var</span> out = <span class="kw">new</span> List[Output]()

    <span class="kw">for</span> (data &lt;- input) {
        out += <span class="fu">processData</span>(data)
    }
    <span class="kw">return</span> out
}</code></pre>
<p>Now a functional version using <code>map</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">processList</span>(input: List[Input]) : List[Output] = {
   input.<span class="fu">map</span>(processData)
}</code></pre>
<p>Using <code>map</code> improves code readability. It may be hard to tell what a handwritten for loop does at a glance, but <code>map</code>:</p>
<ul>
<li>always traverses each element</li>
<li>always applies the same function to each element in the same way</li>
</ul>
</div>
<div class="section slide level1" id="quick-note-on-scala-anonymous-functions">
<h1 id="quick-note-on-scala-anonymous-functions">Quick Note on Scala Anonymous Functions</h1>
<p>The following functions are all equivalent.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(x =&gt; x + <span class="dv">1</span>)

List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(_ + <span class="dv">1</span>)

<span class="co">// def add1(x: Int) = x + 1</span>

List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(x =&gt; <span class="fu">add1</span>(x))

List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>).<span class="fu">map</span>(add1)</code></pre>
</div>
<div class="section slide level1" id="filter">
<h1 id="filter">Filter</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">filter</span> _ []     <span class="fu">=</span> []
<span class="fu">filter</span> p (x<span class="fu">:</span>xs) <span class="fu">=</span>
    <span class="kw">if</span> p x
       <span class="kw">then</span> x <span class="fu">:</span> <span class="fu">filter</span> p xs
       <span class="kw">else</span>     <span class="fu">filter</span> p xs</code></pre>
<p>Let apply <code>filter</code> step by step to see how it works.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">filter</span> <span class="fu">odd</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">odd</span> [<span class="dv">2</span>,<span class="dv">3</span>]  <span class="co">-- 1 is odd</span>
                   <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">odd</span> [<span class="dv">3</span>]    <span class="co">-- 2 is not odd</span>
                   <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">odd</span> [] <span class="co">-- 3 is odd</span>
                   <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> []
                   <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">3</span>]</code></pre>
<p>An iterative function to remove odd numbers from a <code>List</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onlyEvens</span>(xs: List[Int]) : List[Int] = {
    <span class="kw">var</span> acc = <span class="kw">new</span> List[Int]()
    <span class="kw">for</span> (x &lt;- xs) {
        <span class="kw">if</span> (x % <span class="dv">2</span> == <span class="dv">0</span>) {
            acc += x
        }
    }
    <span class="kw">return</span> acc
}</code></pre>
<p>and a functional version using <code>filter</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onlyEvens</span>(xs: List[Int]) : List[Int] = {
    xs.<span class="fu">filter</span>(_ % <span class="dv">2</span> == <span class="dv">0</span>)
}</code></pre>
</div>
<div class="section slide level1" id="foldr">
<h1 id="foldr">Foldr</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
<span class="fu">foldr</span> _ acc []     <span class="fu">=</span> acc
<span class="fu">foldr</span> f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (<span class="fu">foldr</span> f acc xs)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="co">-- combining function</span>
      <span class="ot">-&gt;</span>  b            <span class="co">-- initial value</span>
      <span class="ot">-&gt;</span> [a]           <span class="co">-- list of a&#39;s</span>
      <span class="ot">-&gt;</span>  b            <span class="co">-- final value</span></code></pre>
<p>Think of folds whenever you want to reduce a <code>List</code> of &quot;things&quot; into a single &quot;thing&quot;.</p>
<p>Lets apply <code>foldr</code> step by step to see how it works.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">sum</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">sum</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> xs</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">2</span>,<span class="dv">3</span>])
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">3</span>]))
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> (<span class="fu">foldr</span> (<span class="fu">+</span>) <span class="dv">0</span> [])))
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)
            <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span>
            <span class="fu">=</span> <span class="dv">6</span></code></pre>
</div>
<div class="section slide level1" id="foldr-1">
<h1 id="foldr-1">Foldr</h1>
<p>Like <code>map</code>, <code>fold</code> has strong properties that make it easy to reason about. Of them, a <code>fold</code>:</p>
<ul>
<li><p>always traverses each element in the collection you're folding over</p></li>
<li><p>always applies the same combining function to each element in the same way</p></li>
</ul>
<p><code>foldr</code> also has an important <em>Universal Property</em> that allows compilers to perform an optimization called <code>foldr/build</code> fusion to reduce the amount of intermediate list allocations required in code that processes lists heavily.</p>
</div>
<div class="section slide level1" id="foldr-2">
<h1 id="foldr-2">Foldr</h1>
<p>Here's an iterative factorial function</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">factorial</span>(n: Int): Int = {
    <span class="kw">var</span> res = <span class="dv">1</span>
    <span class="kw">for</span> (x &lt;- <span class="dv">1</span> until n + <span class="dv">1</span>) {
        res *= x
    }
    <span class="kw">return</span> res
}</code></pre>
<p>and the functional version using <code>foldr</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">factorial</span>(n: Int): Int = {
    (<span class="dv">1</span> until n + <span class="dv">1</span>).<span class="fu">fold</span>(<span class="dv">1</span>)(_*_)
}</code></pre>
</div>
<div class="section slide level1" id="foldr-3">
<h1 id="foldr-3">Foldr</h1>
<p>Another example</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">parseMessages</span>(msgs: List[AISMessage]) : ParseResult = {
    <span class="kw">var</span> result = <span class="kw">new</span> <span class="fu">ParseResult</span>()

    <span class="kw">for</span> (msg &lt;- msgs) {
        result += msg.<span class="fu">parse</span>()
    }
    <span class="kw">return</span> result
}</code></pre>
<p>and a functional version using <code>foldr</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">parseMessages</span>(msgs: List[AISMessage]) : ParseResult = {
    <span class="kw">var</span> result = <span class="kw">new</span> <span class="fu">ParseResult</span>()
    msgs.<span class="fu">fold</span>(result)((msg, res) =&gt; res += msg.<span class="fu">parse</span>())
}</code></pre>
</div>
<div class="section slide level1" id="foldr-4">
<h1 id="foldr-4">Foldr</h1>
<p>Many common functions are <code>foldr</code> in disguise!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">reverse</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> xs <span class="fu">++</span> [x]) [] xs
<span class="co">-- reverse = foldl (flip (:)) []</span>
<span class="co">-- foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span>

<span class="fu">maximum</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">maximum</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">foldr</span> <span class="fu">max</span> x xs

<span class="fu">concat</span><span class="ot"> ::</span> [[a]] <span class="ot">-&gt;</span> [a]
<span class="fu">concat</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">++</span>) [] xs

<span class="fu">all</span><span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">all</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">&amp;&amp;</span>) <span class="kw">True</span> xs

<span class="fu">any</span><span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">any</span> xs <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">||</span>) <span class="kw">False</span> xs

<span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">filter</span> p xs <span class="fu">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="fu">:</span> xs <span class="kw">else</span> xs) [] xs

<span class="fu">map</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="fu">map</span> f xs <span class="fu">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> f x <span class="fu">:</span> xs) [] xs</code></pre>
</div>
<div class="section slide level1" id="foldr-5">
<h1 id="foldr-5">Foldr</h1>
<p>But <code>List</code> aren't the only things we can fold.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)

<span class="ot">foldTree ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b
foldTree f z (<span class="dt">Leaf</span> a)       <span class="fu">=</span> f a z
foldTree f z (<span class="dt">Branch</span> l a r) <span class="fu">=</span> f a (foldTree f (foldTree f z r) l)</code></pre>
<p>In fact, many data structures support folding operations. Haskell defines a <code>Foldable</code> typeclass.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Foldable</span> f <span class="kw">where</span>
<span class="ot">    foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> b
<span class="ot">    foldl ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> a
<span class="ot">    foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> m
    <span class="fu">...</span></code></pre>
<p>For example, <code>Maybe</code> has a <code>Foldable</code> instance.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Foldable</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    <span class="fu">foldr</span> _ z <span class="kw">Nothing</span>  <span class="fu">=</span> z
    <span class="fu">foldr</span> f z (<span class="kw">Just</span> a) <span class="fu">=</span> f a z</code></pre>
<p>You can always expect a <code>fold</code> over any foldable structure to behave like a <code>fold</code> over a <code>List</code>. We can write this as a &quot;law&quot; that says</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Foldable</span><span class="fu">.foldr</span> f z xs <span class="fu">==</span> List.foldr f z (toList xs)</code></pre>
<p>Scala doesnt directly define a <code>Foldable</code> class or trait, instead classes like <code>List</code>, <code>Map</code> and <code>Option</code> provide their own <code>foldRight</code> and <code>foldLeft</code> methods that behave just like <code>foldr</code> and <code>foldl</code>.</p>
</div>
<div class="section slide level1" id="more-recursive-primitives">
<h1 id="more-recursive-primitives">More Recursive Primitives</h1>
<p>There are many more basic recursive functions in a functional programmer's arsenal. It would be time consuming to explain them all, but here are a few examples.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]

<span class="fu">zip</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]
<span class="co">-- zip == zipWith (\a b -&gt; (a, b))</span>

<span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]

<span class="fu">iterate</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</code></pre>
</div>
<div class="section slide level1" id="intermediate-functional-concepts">
<h1 id="intermediate-functional-concepts">Intermediate Functional Concepts</h1>
<h2 id="higher-order-types">Higher Order Types</h2>
<p>First we need to understand higher order (or partially applied) types. A good analogy are generics in langauges like Java and C++. Higher order types are applied to concrete types to create new concrete types.</p>
<p>Haskell examples</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span><span class="ot">    ::</span> <span class="fu">*</span>
[]<span class="ot">     ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
[<span class="dt">Int</span>]<span class="ot">  ::</span> <span class="fu">*</span>
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="ot">(-&gt;)   ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre>
<p>Scala examples</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Int       :: *
List      :: * -&gt; *
List[Int] :: *
Option    :: * -&gt; *
Option[List[Int]] :: *
Option[List] <span class="co">// kind mis-match!</span></code></pre>
<p>The &quot;type&quot; of a type is called a kind. We say <code>Option</code> has kind <code>* -&gt; *</code>.</p>
</div>
<div class="section slide level1" id="functors">
<h1 id="functors">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
<p>A <code>Functor</code> is formally defined in category theory. Don't worry though, you'll never need to understand category theory to use <code>Functor</code>!</p>
<p>Let <span class="math"><em>C</em></span> and <span class="math"><em>D</em></span> be categories. A <code>Functor</code> from <span class="math"><em>C</em></span> to <span class="math"><em>D</em></span> is a mapping that</p>
<ul>
<li><p>associates each object <span class="math"><em>X</em> ∈ <em>C</em></span> with an object <span class="math"><em>F</em>(<em>X</em>) ∈ <em>D</em></span></p></li>
<li><p>associates each morphism <span class="math"><em>φ</em>: <em>X</em> → <em>Y</em> ∈ <em>C</em></span> with a morphism</p>
<p><span class="math"><em>F</em>(<em>φ</em>): <em>F</em>(<em>X</em>) → <em>F</em>(<em>Y</em>) ∈ <em>D</em></span></p>
<p>such that the following two conditions hold:</p>
<ul>
<li><span class="math"><em>F</em>(<em>i</em><em>d</em><sub><em>x</em></sub>) = <em>i</em><em>d</em><sub><em>F</em>(<em>X</em>)</sub></span> for all objects <span class="math"><em>X</em> ∈ <em>C</em></span></li>
<li><span class="math"><em>F</em>(<em>φ</em> ∘ <em>ψ</em>) = <em>F</em>(<em>φ</em>) ∘ <em>F</em>(<em>ψ</em>)</span> for all morphisms <span class="math"><em>φ</em>: <em>X</em> → <em>Y</em>, <em>ψ</em>: <em>Y</em> → <em>Z</em></span></li>
</ul></li>
</ul>
<p>We can write these laws in Haskell as</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">fmap</span> <span class="fu">id</span> <span class="fu">==</span> <span class="fu">id</span>
<span class="fu">fmap</span> (f <span class="fu">.</span> g) <span class="fu">==</span> <span class="fu">fmap</span> f <span class="fu">.</span> <span class="fu">fmap</span> g</code></pre>
</div>
<div class="section slide level1" id="functors-1">
<h1 id="functors-1">Functors</h1>
<p>This is a very generalized mathematical definition. In practice a programming language is only concerned with one category: the category of types representable in the language (<code>Hask</code> in Haskell).</p>
<p>In this category, objects are just the types of kind <code>*</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Maybe</span> <span class="dt">Char</span>, a</code></pre>
<p>and morphisms are just functions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>, [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>, a <span class="ot">-&gt;</span> b</code></pre>
<p>So our requirements for a <code>Functor</code> becomes</p>
<ul>
<li>associates each type <code>a</code> with a type <code>f a</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">-&gt;</span> f a</code></pre>
<ul>
<li>associates each function <code>a -&gt; b</code> with a function <code>f a -&gt; f b</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
</div>
<div class="section slide level1" id="functors-2">
<h1 id="functors-2">Functors</h1>
<p>Let take another look at the <code>Functor</code> typeclass</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
<p>The definition for the <code>Functor</code> class only defines the second requirement!</p>
<p>It seems like something is missing, until we realize the constructor for our <code>Functor</code> satisfies the first mapping, and so all is well.</p>
</div>
<div class="section slide level1" id="functors-3">
<h1 id="functors-3">Functors</h1>
<p>Here are some examples to help this sink in</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Id</span> a

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b)
    <span class="fu">fmap</span> f (<span class="dt">Id</span> a) <span class="fu">=</span> <span class="dt">Id</span> (f a)

<span class="kw">instance</span> <span class="kw">Functor</span> [] <span class="kw">where</span>
    <span class="co">-- looks very similar to map!</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> [b])
    <span class="fu">fmap</span> _ []     <span class="fu">=</span> []
    <span class="fu">fmap</span> f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> <span class="fu">fmap</span> f xs

<span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="kw">Nothing</span> <span class="fu">|</span> <span class="kw">Just</span> a

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b)
    <span class="fu">fmap</span> _ <span class="kw">Nothing</span>  <span class="fu">=</span> <span class="kw">Nothing</span>
    <span class="fu">fmap</span> f (<span class="kw">Just</span> a) <span class="fu">=</span> <span class="kw">Just</span> (f a)

<span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="kw">Left</span> a <span class="fu">|</span> <span class="kw">Right</span> b

<span class="kw">instance</span> <span class="kw">Functor</span> (<span class="dt">Either</span> a) <span class="kw">where</span>
    <span class="fu">fmap</span> _ (<span class="kw">Left</span>  a) <span class="fu">=</span> <span class="kw">Left</span> a
    <span class="fu">fmap</span> f (<span class="kw">Right</span> b) <span class="fu">=</span> <span class="kw">Right</span> (f b)

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> b)
    <span class="fu">fmap</span> f (<span class="dt">Leaf</span> a)     <span class="fu">=</span> <span class="dt">Leaf</span> (f a)
    <span class="fu">fmap</span> f (<span class="dt">Branch</span> l r) <span class="fu">=</span> <span class="dt">Branch</span> (<span class="fu">fmap</span> f l) (f a) (<span class="fu">fmap</span> f r)</code></pre>
<p>In a language with <code>Future</code>, we can make <code>Future</code> an instance of <code>Functor</code>. How would <code>fmap</code> behave?</p>
</div>
<div class="section slide level1" id="functors-4">
<h1 id="functors-4">Functors</h1>
<p>We can think of a <code>Functor</code> as some kind of &quot;context&quot; around a pure value. We use <code>fmap</code> to lift a function on pure values to a function on values in this &quot;context&quot;, and <code>fmap</code> automagically knows what instance of <code>Functor</code> to use!</p>
<p>Scala by default doesn't define <code>Functor</code>, instead classes like <code>List</code>, <code>Map</code> and <code>Option</code> define their own <code>map</code> methods that &quot;do the right thing&quot;. These are exactly the same as their would-be <code>Functor</code> instances.</p>
</div>
<div class="section slide level1" id="functors-5">
<h1 id="functors-5">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="functors-6">
<h1 id="functors-6">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="functors-7">
<h1 id="functors-7">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="functors-8">
<h1 id="functors-8">Functors</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="dt">Pure</span> (f r)</code></pre>
</div>
<div class="section slide level1" id="monads">
<h1 id="monads">Monads</h1>
<blockquote>
<p>&quot;A monad is just a monoid in the category of endofunctors, what's the problem?&quot;</p>
</blockquote>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a

<span class="ot">    join ::</span> m (m a) <span class="ot">-&gt;</span> m a
    join mm <span class="fu">=</span> mm <span class="fu">&gt;&gt;=</span> <span class="fu">id</span>

<span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
    m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> join (<span class="fu">fmap</span> f m)</code></pre>
<p>We can see from the definition that a <code>Monad</code> must also be a <code>Functor</code>. Indeed, a <code>Monad</code> is strictly more powerful than a <code>Functor</code> because we can derive a <code>Functor</code> instance from any <code>Monad</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (m a <span class="ot">-&gt;</span> m b)
<span class="fu">fmap</span> f m <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="fu">return</span> (f a)</code></pre>
</div>
<div class="section slide level1" id="monads-1">
<h1 id="monads-1">Monads</h1>
<p><code>Monads</code> are also formally defined in category theory:</p>
<p>Let <span class="math"><em>C</em></span> be a category. A <code>Monad</code> on <span class="math"><em>C</em></span> consists of a (endo)functor <span class="math"><em>T</em>: <em>C</em> → <em>C</em></span>, together with two natural transformations</p>
<p><span class="math"><em>u</em><em>n</em><em>i</em><em>t</em>: <em>X</em> → <em>T</em>(<em>X</em>)</span> and <span class="math"><em>j</em><em>o</em><em>i</em><em>n</em>: <em>T</em>(<em>T</em>(<em>X</em>)) → <em>T</em>(<em>X</em>)</span></p>
<p>such that the following two conditions hold:</p>
<ul>
<li><span class="math"><em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>T</em>(<em>j</em><em>o</em><em>i</em><em>n</em>) = <em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>j</em><em>o</em><em>i</em><em>n</em></span></li>
<li><span class="math"><em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>u</em><em>n</em><em>i</em><em>t</em> = <em>i</em><em>d</em> = <em>j</em><em>o</em><em>i</em><em>n</em> ∘ <em>T</em>(<em>u</em><em>n</em><em>i</em><em>t</em>)</span></li>
</ul>
<p>The formal definition uses <code>join</code>, but the more useful operation in practice is <code>(&gt;&gt;=)</code>, pronounced &quot;bind&quot;. In terms of <code>(&gt;&gt;=)</code> these laws become</p>
<p>Left Identity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">return</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">==</span> f a</code></pre>
<p>Right Identity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">==</span> m</code></pre>
<p>Associativity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g <span class="fu">==</span> m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)
<span class="co">-- (m &gt;&gt;= f) &gt;&gt;= g == m &gt;&gt;= (f &gt;=&gt; g)</span></code></pre>
</div>
<div class="section slide level1" id="monads-2">
<h1 id="monads-2">Monads</h1>
<p>To make a <code>Monad</code> instance, we need two things</p>
<ul>
<li><p>a function to create a monadic action that does nothing but return a value</p></li>
<li><p>a function to apply a monadic function to the result of a monadic action</p></li>
</ul>
<p>Some example <code>Monad</code> instances</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Id</span> a
    join (<span class="dt">Id</span> (<span class="dt">Id</span> a)) <span class="fu">=</span> <span class="dt">Id</span> a

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> <span class="dt">Identity</span> b
    <span class="dt">Id</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">List</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> [a]
    join xs <span class="fu">=</span> <span class="fu">concat</span> xs

<span class="ot">    (&gt;&gt;=) ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [b]
    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">concat</span> (<span class="fu">map</span> f xs)

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="kw">Just</span> a

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
    <span class="kw">Nothing</span> <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Nothing</span>
    <span class="kw">Just</span> a  <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a

<span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">Either</span> a) <span class="kw">where</span>
    <span class="fu">return</span> b <span class="fu">=</span> <span class="kw">Right</span> b

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a c
    <span class="kw">Left</span>  a <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Left</span> a
    <span class="kw">Right</span> b <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f b

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Tree</span> <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a

<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Tree</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> b
    <span class="dt">Leaf</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a
    <span class="dt">Branch</span> l r <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Branch</span> (l <span class="fu">&gt;&gt;=</span> f) (r <span class="fu">&gt;&gt;=</span> f)</code></pre>
</div>
<div class="section slide level1" id="monads-3">
<h1 id="monads-3">Monads</h1>
<p>Again, Scala by default doesnt define <code>Monad</code>, instead classes like <code>List</code>, <code>Map</code> and <code>Option</code> define their own <code>flatMap</code> methods. These <code>flatMap</code> methods behave exactly like <code>(&gt;&gt;=)</code>.</p>
<p>Scala does provide some nice syntactic sugar for monadic operations that is very similar to do notation in Haskell.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- List(<span class="dv">1</span>, <span class="dv">2</span>)
    y &lt;- List(<span class="dv">3</span>, <span class="dv">4</span>)
    z = (x, y)
} <span class="kw">yield</span> z
-- List((<span class="dv">1</span>,<span class="dv">3</span>), (<span class="dv">1</span>,<span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">2</span>,<span class="dv">4</span>))</code></pre>
<p>This desugars to nested <code>flatMap</code>s</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List(<span class="dv">1</span>,<span class="dv">2</span>).<span class="fu">flatMap</span>(x =&gt; List(<span class="dv">3</span>,<span class="dv">4</span>).<span class="fu">flatMap</span>(y =&gt; List((x, y))))</code></pre>
<p>This is a good example of the monadic effect of <code>List</code>, non-determinism! Think of the <code>List</code> <code>Monad</code> as a computation that doesnt know what its result might be, instead of operating on just one result, you operate on all possible results.</p>
<p>Here is a interesting example of non-determinism in the <code>List</code> <code>Monad</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterM ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
<span class="ot">powerset ::</span> [a] <span class="ot">-&gt;</span> [[a]]
powerset xs <span class="fu">=</span> filterM (<span class="fu">const</span> [<span class="kw">True</span>, <span class="kw">False</span>]) xs
<span class="co">-- powerset [1,2,3] = [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]</span></code></pre>
</div>
<div class="section slide level1" id="monads-4">
<h1 id="monads-4">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-5">
<h1 id="monads-5">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next    <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-6">
<h1 id="monads-6">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-7">
<h1 id="monads-7">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monads-8">
<h1 id="monads-8">Monads</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> r
    <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Fork</span>  (<span class="dt">Thread</span> r) (<span class="dt">Thread</span> r)
    <span class="fu">|</span> <span class="dt">Pure</span>  r

<span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Thread</span> <span class="kw">where</span>
    <span class="fu">return</span> r <span class="fu">=</span> <span class="dt">Pure</span> r

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r</code></pre>
</div>
<div class="section slide level1" id="monads-9">
<h1 id="monads-9">Monads</h1>
<p><code>Option</code> is a very useful abstraction that saves us from the dreaded <code>NullPointerException</code>. With <code>Option</code>, we can tell the compiler &quot;this computation might fail to return a result&quot;, and the compiler will make sure that we always handle the failure case. If we don't, the code won't compile!</p>
<h2 id="section">1</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- None
    z = x + y
} <span class="kw">yield</span> z</code></pre>
<h2 id="section-1">2</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- Some(<span class="dv">5</span>)
    z = x + y
} <span class="kw">yield</span> z</code></pre>
</div>
<div class="section slide level1" id="monads-10">
<h1 id="monads-10">Monads</h1>
<p><code>Option</code> is a very useful abstraction that saves us from the dreaded <code>NullPointerException</code>. With <code>Option</code>, we can tell the compiler &quot;this computation might fail to return a result&quot;, and the compiler will make sure that we always handle the failure case. If we don't, the code won't compile!</p>
<h2 id="section-2">1</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- None
    z = x + y
} <span class="kw">yield</span> z
-- None</code></pre>
<h2 id="section-3">2</h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
    x &lt;- Some(<span class="dv">4</span>)
    y &lt;- Some(<span class="dv">5</span>)
    z = x + y
} <span class="kw">yield</span> z
-- Some(<span class="dv">9</span>)</code></pre>
</div>
<div class="section slide level1" id="monads-11">
<h1 id="monads-11">Monads</h1>
<p>The <code>Option</code> <code>Monad</code> represents a computation that could possibly fail to return a result at one or more points. If any subcomputation returns <code>Nothing</code>, the entire computation should return <code>Nothing</code>.</p>
<p>You may consider using <code>Option</code> instead of <code>try/catch</code> blocks. Instead of throwing an exception if a computation fails (ex. establishing a database connection), return <code>None</code> instead and let the calling function decide how to handle the failure.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">bothGrandFathers</span>(person: Person): Option[(Person, Person)] =
    person.<span class="fu">getFather</span>() <span class="kw">match</span> {
        <span class="kw">case</span> None =&gt; None
        <span class="kw">case</span> Some(father) =&gt; father.<span class="fu">getFather</span>() <span class="kw">match</span> {
          <span class="kw">case</span> None =&gt; None
          <span class="kw">case</span> Some(grandFather1) =&gt; person.<span class="fu">getMother</span>() <span class="kw">match</span> {
            <span class="kw">case</span> None =&gt; None
            <span class="kw">case</span> Some(mother) =&gt; mother.<span class="fu">getFather</span>() <span class="kw">match</span> {
              <span class="kw">case</span> None =&gt; None
              <span class="kw">case</span> Some(grandFather1) =&gt;
                Some((grandFather1, grandFather2))
            }
          }
        }
}</code></pre>
</div>
<div class="section slide level1" id="monads-12">
<h1 id="monads-12">Monads</h1>
<p>A much more readable version using the <code>Option</code> <code>Monad</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">bothGrandFathers</span>(person: Person): Option[(Person, Person)] = <span class="kw">for</span> {
  father       &lt;- person.<span class="fu">getFather</span>()
  grandFather1 &lt;- father.<span class="fu">getFather</span>()
  mother       &lt;- person.<span class="fu">getMother</span>()
  grandFather2 &lt;- mother.<span class="fu">getFather</span>()
} <span class="kw">yield</span> (grandFather1, grandFather2)</code></pre>
</div>
<div class="section slide level1" id="monads-13">
<h1 id="monads-13">Monads</h1>
<p><code>Monads</code> are not some just some abstract category theory nonsense, they are simply a common design pattern of sequencing effects that has been abstracted into a functional interface.</p>
<p>Other <code>Monad</code>s can provide effects such as</p>
<ul>
<li><p>read-only/write-only state</p></li>
<li><p>read/write state</p></li>
<li><p>continuations</p></li>
<li><p>parallelism/concurrency</p></li>
<li><p>Software Transactional Memory</p></li>
<li><p>I/O effects</p></li>
<li><p>streaming resources</p></li>
<li><p>Domain Specific Languages</p></li>
</ul>
</div>
<div class="section slide level1" id="monad-transformers">
<h1 id="monad-transformers">Monad Transformers</h1>
<p>The real power of <code>Monad</code>s comes from their composability. You can choose which side-effects you want to allow your computations access to (alternatively, what side-effects you DON'T want them to have access to).</p>
<p>The compiler ensures you don't accidently use any side-effects that you haven't explicitly mentioned, which helps reduce programming errors.</p>
<p>To layer <code>Monad</code>s on top of one another, we'll need <code>MonadTrans</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    lift ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre>
<p>which satisfies these laws</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">lift (<span class="fu">return</span> x) <span class="fu">==</span> <span class="fu">return</span> x
lift (m <span class="fu">&gt;&gt;=</span> f)  <span class="fu">==</span> (lift m) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> lift (f x))</code></pre>
<p>Whoa, that kind signature looks pretty scary!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="co">-- a Monad</span>
  <span class="ot">-&gt;</span> <span class="fu">*</span>        <span class="co">-- a concrete type</span>
  <span class="ot">-&gt;</span> <span class="fu">*</span>        <span class="co">-- we get a concrete type back</span></code></pre>
</div>
<div class="section slide level1" id="monad-transformers-1">
<h1 id="monad-transformers-1">Monad Transformers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> m r
    <span class="fu">=</span> <span class="dt">Yield</span>   (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Fork</span>    (<span class="dt">Thread</span> m r) (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Lift</span> (m (<span class="dt">Thread</span> m r))
    <span class="fu">|</span> <span class="dt">Pure</span>  r
    <span class="fu">|</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Functor</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Lift</span> m)          <span class="fu">=</span> <span class="dt">Lift</span> (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) m)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="dt">Pure</span> (f r)
    <span class="fu">fmap</span> f  <span class="dt">Done</span>             <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Pure</span> a

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Lift</span> m          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Lift</span> (m <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r
    <span class="dt">Done</span>            <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">Thread</span> a) <span class="kw">where</span>
    lift m <span class="fu">=</span> <span class="fu">...</span></code></pre>
</div>
<div class="section slide level1" id="monad-transformers-2">
<h1 id="monad-transformers-2">Monad Transformers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thread</span> m r
    <span class="fu">=</span> <span class="dt">Yield</span>   (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Fork</span>    (<span class="dt">Thread</span> m r) (<span class="dt">Thread</span> m r)
    <span class="fu">|</span> <span class="dt">Lift</span> (m (<span class="dt">Thread</span> m r))
    <span class="fu">|</span> <span class="dt">Pure</span>  r
    <span class="fu">|</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Functor</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">fmap</span> f (<span class="dt">Yield</span> next)      <span class="fu">=</span> <span class="dt">Yield</span> (<span class="fu">fmap</span> f next)
    <span class="fu">fmap</span> f (<span class="dt">Fork</span> left right) <span class="fu">=</span> <span class="dt">Fork</span> (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)
    <span class="fu">fmap</span> f (<span class="dt">Lift</span> m)          <span class="fu">=</span> <span class="dt">Lift</span> (liftM (<span class="fu">fmap</span> f) m)
    <span class="fu">fmap</span> f (<span class="dt">Pure</span> r)          <span class="fu">=</span> <span class="dt">Pure</span> (f r)
    <span class="fu">fmap</span> f  <span class="dt">Done</span>             <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="dt">Thread</span> m) <span class="kw">where</span>
    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Pure</span> a

    <span class="dt">Yield</span> next      <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Yield</span> (next <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Fork</span> left right <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Fork</span> (left <span class="fu">&gt;&gt;=</span> f) (right <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Lift</span> m          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Lift</span> (m <span class="fu">&gt;&gt;=</span> f)
    <span class="dt">Pure</span> r          <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r
    <span class="dt">Done</span>            <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Done</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">Thread</span> a) <span class="kw">where</span>
    lift m <span class="fu">=</span> <span class="dt">Lift</span> (liftM <span class="dt">Pure</span> m)</code></pre>
</div>
<div class="section slide level1" id="monad-transformers-3">
<h1 id="monad-transformers-3">Monad Transformers</h1>
<p>In the few lines of code in the last slide, we've created a fully usable co-operative thread DSL. All we need are a few smart constructors.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">yield ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m ()
yield <span class="fu">=</span> <span class="dt">Yield</span> (<span class="dt">Pure</span> ())

<span class="ot">done ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m r
done <span class="fu">=</span> <span class="dt">Done</span>

<span class="ot">fork ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m r <span class="ot">-&gt;</span> <span class="dt">Thread</span> m ()
fork thread <span class="fu">=</span> <span class="kw">do</span>
    child <span class="ot">&lt;-</span> <span class="dt">Fork</span> (<span class="dt">Pure</span> <span class="kw">False</span>) (<span class="dt">Pure</span> <span class="kw">True</span>)
    when child <span class="fu">$</span> thread <span class="fu">&gt;&gt;</span> done</code></pre>
<p>and a roundRobin thread scheduler</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">roundRobin ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Thread</span> m a <span class="ot">-&gt;</span> m ()
roundRobin t0 <span class="fu">=</span> go (singleton t0)
  <span class="kw">where</span>
    go ts <span class="fu">=</span> <span class="kw">case</span> viewl ts <span class="kw">of</span>
        <span class="co">-- The queue is empty: we&#39;re done!</span>
        <span class="dt">EmptyL</span>   <span class="ot">-&gt;</span> <span class="fu">return</span> ()
        <span class="co">-- The queue is non-empty: Process the first thread</span>
        t <span class="fu">:&lt;</span> ts <span class="ot">-&gt;</span> <span class="kw">case</span> t <span class="kw">of</span>
            <span class="co">-- Yielding threads go to the back of the queue</span>
            <span class="dt">Yield</span>   t&#39; <span class="ot">-&gt;</span> go (ts <span class="fu">|&gt;</span> t&#39;)
            <span class="co">-- New threads go to the back of the queue</span>
            <span class="dt">Fork</span> t1 t2 <span class="ot">-&gt;</span> go (t1 <span class="fu">&lt;|</span> (ts <span class="fu">|&gt;</span> t2))
            <span class="co">-- Run effects in the base monad</span>
            <span class="dt">Lift</span>    m  <span class="ot">-&gt;</span> m <span class="fu">&gt;&gt;=</span> \t&#39; <span class="ot">-&gt;</span> go (t&#39; <span class="fu">&lt;|</span> ts)
            <span class="co">-- Thread done: Remove the thread from the queue</span>
            _          <span class="ot">-&gt;</span> go ts</code></pre>
</div>
<div class="section slide level1" id="monad-transformers-4">
<h1 id="monad-transformers-4">Monad Transformers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mainThread ::</span> <span class="dt">Thread</span> <span class="dt">IO</span> ()
mainThread <span class="fu">=</span> <span class="kw">do</span>
    lift <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Forking thread #1&quot;</span>
    fork thread1
    lift <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Forking thread #2&quot;</span>
    fork thread2

<span class="ot">thread1 ::</span> <span class="dt">Thread</span> <span class="dt">IO</span> ()
thread1 <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span>
    lift <span class="fu">$</span> <span class="fu">print</span> i
    yield

<span class="ot">thread2 ::</span> <span class="dt">Thread</span> <span class="dt">IO</span> ()
thread2 <span class="fu">=</span> replicateM_ <span class="dv">3</span> <span class="fu">$</span> <span class="kw">do</span>
    lift <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Hello World&quot;</span>
    yield</code></pre>
<p>Now if we run our <code>mainThread</code> using <code>roundRobin</code> we'll see</p>
<pre><code>Forking thread #1
Forking thread #2
1
Hello World
2
Hello World
3
Hello World
4
5
6
7
8
9
10</code></pre>
<p>We've used our <code>Thread</code> transformer to layer <code>IO</code> effects (printing to stdout in this case) with our threading effects.</p>
</div>
</body>
</html>
