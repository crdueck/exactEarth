\documentclass[12pt]{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}

\setlength{\parindent}{0pt}

\lstnewenvironment{haskell}
    {\lstset{language=haskell, mathescape=true}}
    {}

\lstnewenvironment{scala}
    {\lstset{language=java}}
    {}

\newcommand{\Monad}{\texttt{Monad}}

\begin{document}

\section*{Haskell at a Glance}

\begin{haskell}
data List a = [] | a : List a
-- []  :: List a
-- (:) :: a -> List a -> List a

myList :: [Int]
myList = 1 : (2 : (3 : []))
-- or myList = [1,2,3]
-- or myList = [1..3]

-- pattern matching
null :: [a] -> Bool
null []     = True
null (x:xs) = False

-- curried function
add3 :: Int -> Int -> Int -> Int
add3 x y z = x + y + z

-- partially applied function
add2 :: Int -> Int -> Int
add2 = add3 0

-- wildcards
const :: a -> b -> a
const x _ = x

-- lambda
flip :: (a -> b -> c) -> b -> (a -> c)
flip f b = $\lambda$a -> f a b
\end{haskell}
$ \blacksquare $
\newpage
\section*{Functional Programming Basics}

\begin{haskell}
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
\end{haskell}

Here's an iterative function to add 1 to each element of a \texttt{List}
\begin{scala}
def add1(xs: List[Int]) : List[Int] = {
    for (i <- xs.length) {
        xs[i] += 1
    }
}
\end{scala}

Now a functional version
\begin{scala}
def add1(xs: List[Int]) : List[Int] = {
    xs.map(_ + 1)
}
\end{scala}

Using \texttt{map} improves code readability.  I can't tell what a handwritten
for loop might do at a glance, but I have strong guarantees on \texttt{map}. It
always traverses every element, and it always applies the same function to each
element.
\newpage

\begin{haskell}
filter :: (a -> Bool) -> [a] -> [a]
filter _ []     = []
filter p (x:xs) =
    if p x
       then x : filter p xs
       else     filter p xs
\end{haskell}

An iterative function to remove odd numbers from a \texttt{List}
\begin{scala}
def onlyEvens(xs: List[Int]) : List[Int] = {
    var acc = new List()
    for (x <- xs) {
        if (x % 2 == 0) acc.append(x)
    }
    return acc
}
\end{scala}

and a functional version
\begin{scala}
def onlyEvens(xs: List[Int]) : List[Int] = {
    xs.filter(_ % 2 == 0)
}
\end{scala}

%%TODO more filter stuff
\newpage

\begin{haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ acc []    = acc
foldr f acc (x:xs) = f x (foldr f acc xs)
\end{haskell}

Lets apply \texttt{foldr} step by step to see how this works.
\begin{haskell}
sum :: [Int] -> Int
sum xs = foldr (+) 0 xs
sum [1,2,3] = foldr (+) 0 [1,2,3]
            = 1 + (foldr (+) 0 [2,3])
            = 1 + (2 + (foldr (+) 0 [3]))
            = 1 + (2 + (3 + (foldr (+) 0 [])))
            = 1 + (2 + (3 + 0))
            = 1 + (2 + 3)
            = 1 + 5
            = 6
\end{haskell}

Many functions you might write yourself are \texttt{foldr} in disguise!
Here are some examples:
\begin{haskell}
reverse :: [a] -> [a]
reverse xs = foldr (\x xs -> xs ++ [x]) [] xs
-- reverse = foldl (flip (:)) []
-- foldl :: (a -> b -> a) -> a -> [b] -> a

maximum :: [Int] -> Int
maximum xs = foldr max 0 xs

concat :: [[a]] -> [a]
concat xs = foldr (++) [] xs

all, any :: [Bool] -> Bool
all xs = foldr (&&) True xs
any xs = foldr (||) False xs

filter :: (a -> Bool) -> [a] -> [a]
filter p xs = foldr ($\lambda$x xs -> if p x then x : xs else xs) [] xs

map :: a -> b -> [a] -> [b]
map f xs = foldr ($\lambda$x xs -> f x : xs) [] xs
\end{haskell}

What do all of these functions have in common?  They all take a collection of
``things" (a \texttt{List} in this case) and combine them together in some way
to give you one ``thing" back (possibly of a different type). \\ \\
So, think of folds whenever you want to condense a collection of things to give a
single result. \\

Folds also encompass a simple sort of state, as the combining function is applied to
the result of the previous application.
\begin{haskell}
foldr :: (Input->Result->Result)->Result->[Input]->Result
\end{haskell}
Each time the function is called, it has access to the intermediate result as it
has been computed up to that point. This intermediate result is used to compute
the next intermediate result, and so on. \\

So, think of folds whenever you want to repeatedly apply a function to a
collection of inputs and the function depends the result of previous
applications.

%%TODO: better fold example in Scala
\newpage

But \texttt{List} aren't the only things we can fold.
\begin{haskell}
data Tree a = Leaf a | Branch (Tree a) a (Tree a)

foldTree :: (a -> b -> b) -> b -> Tree a -> b
foldTree f z (Leaf a)       = f a z
foldTree f z (Branch l a r) = f a (foldTree f (foldTree f z r) l)
\end{haskell}

You can always expect a fold over any foldable structure to behave like a fold
over a \texttt{List}. Like map, a fold always traverses every element, and applies the
combining function to each element in the same way.

Here's an iterative factorial function
\begin{scala}
def factorial(n: Int): Int = {
    var res = 1
    for (x <- 1 until n + 1) {
        res *= x
    }
    return res
}
\end{scala}

and the functional version
\begin{scala}
def factorial(n: Int): Int = {
    (1 until n + 1).fold(1)(_*_)
}
\end{scala}
\newpage

\section*{Programming with Class}

First we need to understand higher order types. A good analogy are generics in
langauges like Java and \texttt{C++}. They are applied to concrete types to
create new concrete types.

Haskell examples
\begin{haskell}
Int   :: *
[]    :: * -> *
[Int] :: *
(->)  :: * -> * -> *
\end{haskell}

Scala examples (with stolen kind notation)
\begin{scala}
Int       :: *
List      :: * -> *
List[Int] :: *
Option    :: * -> *
Option[List[Int]] :: *
Option[List] // kind mis-match!
\end{scala}

The ``type" of a type is called a kind. We say \texttt{Option} has kind \texttt{* -> *}.
\newpage

\begin{haskell}
class Functor (f :: * -> *) where
    fmap :: (a -> b) -> (f a -> f b)
\end{haskell}

A \texttt{Functor} is formally defined in Category Theory but don't worry, you dont need
to understand any of this to use \texttt{Functor}!\\
Let $C$ and $D$ be categories. A \textbf{Functor} from $C$ to $D$ is a mapping that
\begin{itemize}
    \item{associates each object ${X \in C}$ with an object ${F(X) \in D}$}
    \item{associates each morphism ${f : X \rightarrow Y \in C}$ with a morphism ${F(f) : F(X) \rightarrow F(Y) \in D}$ such that the following two conditions hold:
            \begin{itemize}
                \item{${F(id_x) = id_{F(X)}}$ for all objects ${X \in C}$}
                \item{${F(g \circ f) = F(g) \circ F(f)}$ for all morphisms ${f : X \rightarrow Y, g : Y \rightarrow Z}$}
        \end{itemize}}
\end{itemize}

These laws can be stated in Haskell as
\begin{haskell}
    fmap id = id
    fmap (f . g) = fmap f . fmap g
\end{haskell}

This is a very generalized mathematical definition. In practice a programming
language will only have one category (\texttt{Hask} in Haskell), so this
simplifies somewhat. \\

To make a \texttt{Functor}, we need two things
\begin{itemize}
    \item{a mapping from values of type \texttt{a} to type \texttt{f a}}
    \item{a mapping from functions of type \texttt{a -> b} to type \texttt{f a -> f b}}
\end{itemize}
but the definition for the \texttt{Functor} class only defines the second mapping!
It seems like something is missing, until we realize the constructor for our \texttt{Functor}
satisfies the first mapping, and so all is well.
\newpage

Here are some examples to help this sink in
\begin{haskell}
data Identity a = Id a

instance Functor Identity where
    fmap :: (a -> b) -> (Identity a -> Identity b)
    fmap f (Id a) = Id (f a)

instance Functor List where
    -- looks very similar to map
    fmap :: (a -> b) -> ([a] -> [b])
    fmap _ []     = []
    fmap f (x:xs) = f x : fmap f xs

data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap :: (a -> b) -> (Maybe a -> Maybe b)
    fmap _ Nothing  = Nothing
    fmap f (Just a) = Just (f a)

data Tree a = Leaf a | Branch (Tree a) (Tree a)

instance Functor Tree where
    fmap :: (a -> b) -> (Tree a -> Tree b)
    fmap f (Leaf a)     = Leaf (f a)
    fmap f (Branch l r) = Branch (fmap f l) (fmap f r)
\end{haskell}

We can think of a \texttt{Functor} as some kind of ``context" around a pure
value.  We use \texttt{fmap} to lift a function on pure values to a function on
values in this ``context", and \texttt{fmap} automagically knows what instance
of \texttt{Functor} to use! \\

Scala by default doesn't define \texttt{Functor}, instead data structures like
\texttt{List}, \texttt{Map} and \texttt{Option} define their own \texttt{map}
functions that ``do the right thing". These are exactly the same as their
would-be \texttt{Functor} instances.
\newpage

\texttt{Monads} may seem more complicated at first, but are really simple as well
\begin{haskell}
class Functor m => Monad (m :: * -> *) where
    return :: a -> m a

    join :: m (m a) -> m a
    join mm = mm >>= id

    (>>=) :: m a -> (a -> m b) -> m b
    m >>= f = join (fmap f m)
\end{haskell}

\texttt{Monads} are also formally defined in category theory:\\
Let $C$ be a category. A \textbf{Monad} on $C$ consists of a (endo)functor $T : C \rightarrow C$ together with two natural transformations $unit : X \rightarrow T(X)$ and $join : T(T(X)) \rightarrow T(X)$ such that the following two conditions hold:
\begin{itemize}
    \item{$join \circ T(join) = join \circ join$}
    \item{$join \circ unit = id = join \circ T(unit)$}
\end{itemize}

The formal definition uses \texttt{join}, but the more useful operation in practice is
\texttt{(>>=)} pronounced ``bind". In terms of \texttt{(>>=)} these laws become
\begin{itemize}
    \item{Left Identity: \lstinline $ return a >>= f = f a $}
    \item{Right Identity: \lstinline $ m >>= return = m $}
    \item{Associativity: \lstinline $ (m >>= f) >>= g = m >>= (\x -> f x >>= g) $}
\end{itemize}

We can see from the definition that all \texttt{Monads} are \texttt{Functors}.
Indeed, a \texttt{Monad} is strictly more powerful than a \texttt{Functor} because
we can derive a \texttt{Functor} instance from any \texttt{Monad}.
\begin{haskell}
fmap :: Monad m => (a -> b) -> (m a -> m b)
fmap f m = m >>= $\lambda$a -> return (f a)
\end{haskell}
\newpage

To make a \texttt{Monad}, we need two things
\begin{itemize}
    \item{a function to create a monadic action that does nothing but return a value}
    \item{a function to apply a monadic function to the result of a monadic action}
\end{itemize}

Some example Monad instances
\begin{haskell}
instance Monad Identity where
    return a = Id a
    join (Id (Id a)) = Id a

    (>>=) :: Identity a -> (a -> Identity b) -> Identity b
    Id a >>= f = f a

instance Monad List where
    return a = [a]

    (>>=) :: [a] -> (a -> [b]) -> [b]
    xs >>= f = concat (map f xs)

instance Monad Maybe where
    return a = Just a

    (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
    Nothing >>= _ = Nothing
    Just a  >>= f = f a

instance Monad Tree where
    return a = Leaf a

    (>>=) :: Tree a -> (a -> Tree b) -> Tree b
    Leaf a >>= f = f a
    Branch l r >>= f = Branch (l >>= f) (r >>= f)
\end{haskell}

Again, Scala by default doesnt define \texttt{Monad}, instead data structures
like \texttt{List}, \texttt{Map} and \texttt{Option} define their own
\texttt{flatMap} functions. These \texttt{flatMap} functions behave exactly like
\texttt{(>>=)}.

Scala does provide some nice syntactic sugar for monadic operations, that is
very similar to do notation in Haskell.
\begin{scala}
for {
    x <- List(1, 2)
    y <- List(3, 4)
    z = (x, y)
} yield z
-- List((1,3), (1,4), (2,3), (2,4))
\end{scala}
This desugars to a nested \texttt{flatMap} and demonstrates the monadic effect
of \texttt{List}, non-determinism! Think of the \texttt{List} \texttt{Monad} as a
computation that doesnt know what its result might be, instead of operating on
just one result, you operate on all possible results.
\begin{scala}
List(1,2).flatMap(x => List(3,4).flatMap(y => List((x, y))))
\end{scala}

Here is a interesting example of non-determinism in the \texttt{List} \texttt{Monad}.
\begin{haskell}
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
powerset :: [a] -> [[a]]
powerset xs = filterM (const [True, False]) xs
-- powerset [1,2,3] = [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
\end{haskell}
\newpage

\texttt{Option} is a very useful abstraction that saves us from
\texttt{NullPointerException}.  With \texttt{Option}, we can tell the compiler
``this computation might fail", and the compiler will make sure that we always
handle the failure case. If we don't, the code won't compile! This can prevent
many, many subtle bugs.
\begin{scala}
for {
    x <- Some(4)
    y <- Nothing
    z = x + y
} yield z
-- Nothing

for {
    x <- Some(4)
    y <- Some(5)
    z = x + y
} yield z
-- Some(9)
\end{scala}

The \texttt{Option} \texttt{Monad} represents a computation that could possibly
fail to return a result at one or more points. If any subcomputation returns
\texttt{Nothing}, the entire computation should return \texttt{Nothing}.

\begin{scala}
def getFather(person: Person): Option[Person]
def getMother(person: Person): Option[Person]

def bothGrandFathers(person: Person): Option[(Person, Person)] =
    getFather(person) match {
        case Nothing => Nothing
        case Some(father) => getFather(father) match {
          case Nothing => Nothing
          case Some(grandFather1) => getMother(person) match {
            case Nothing => Nothing
            case Some(mother) => getFather(mother) match {
              case Nothing => Nothing
              case Some(grandFather1) => Some((grandFather1, grandFather2))
            }
          }
        }
}

def bothGrandFathers(person: Person): Option[(Person, Person)] = for {
father       <- getFather(person)
grandFather1 <- getFather(father)
mother       <- getMother(person)
grandFather2 <- getFather(mother)
} yield (grandFather1, grandFather2)
\end{scala}
\newpage

\texttt{Monads} are not some just some abstract Category Theory nonsense, they
are simply a common design pattern of sequencing effects that has been
abstracted into a simple interface.

Other \texttt{Monad}s can provide effects such as
\begin{itemize}
    \item{read-only/write-only state}
    \item{read/write state}
    \item{implicit arguments}
    \item{continuations}
    \item{parallelism/concurrency}
    \item{threadsafe, locally impure computations (ex. direct memory access) that appear pure to the outside world}
    \item{Software Transactional Memory}
    \item{I/O effects}
    \item{streaming resource handling}
    \item{Domain Specific Languages}
\end{itemize}

%There exist other categorical constructs that lie between \texttt{Functor} and
%\texttt{Monad} in power, like \texttt{Applicative}.

%\begin{haskell}
    %class Functor f => Applicative f where
        %pure :: a -> f a
        %(<*>) :: f (a -> b) -> f a -> f b
%\end{haskell}

%An important property of \texttt{Monad}s is that the result of a monadic action
%in a sequence of monadic effects can depend on the result of previous actions.
%\begin{haskell}
    %ex = do
        %x <- [1,2,3]
        %y <- if odd x then [] else [4,5,6]
        %return (x + y)
    %-- ex = [6,7,8]
%\end{haskell}

%An \texttt{Applicative} interface allows effects to be sequenced, but doesn't
%allow them to depend on previous results and the compiler can enforce this
%restriction.
\newpage

An example of one of these is the \texttt{Reader} \texttt{Monad}, which provides
statically enforced read-only state (great for config files!)

\begin{haskell}
newtype Reader r a = Reader { runReader :: r -> a }
-- runReader :: Reader r a -> r -> a

instance Functor (Reader r) where
    fmap f (Reader k) = Reader (\r -> f (k r))

instance Monad (Reader r) where
    return a = Reader (const a)
    Reader k >>= f = Reader (\r -> runReader (f (k r)) r)

ask :: Reader r r
ask = Reader id

newtype Config = Config { nice :: Bool }

greetWithConfig :: Reader Config String
greetWithConfig = do
    conf <- ask
    return (if (nice conf) then ``You're awesome!" else ``You suck!")

main = putStrLn (runReader greetWithConfig (Config True))
\end{haskell}

We have no way to modify the state inside the \texttt{Reader} Monad (in fact, the
interface we've defined doesn't even allow such a modification function to
exist), its read-only!
\newpage

The real power of \texttt{Monads} comes from their composability. You can pick and choose
which side-effects you want to allow your computations access to. To do this,
we'll need \texttt{MonadTrans}.

\begin{haskell}
class MonadTrans (t :: (* -> *) -> * -> *) where
    lift :: m a -> t m a
\end{haskell}

The \texttt{MonadTrans} class allows us to wrap \texttt{Monads} inside each other. We'll start by
adding this new ability to \texttt{Reader}.

\begin{haskell}
newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }

instance Monad m => Functor (ReaderT r m) where
    fmap f (ReaderT k) = ReaderT ( \r -> do
        a <- k r
        return (f a) )

instance Monad m => Monad (ReaderT r m) where
    return a = ReaderT (\_ -> return a)
    ReaderT k >>= f = ReaderT ( \r -> do
        a <- k r
        runReaderT (f a) r )

instance MonadTrans (ReaderT r) where
    lift m = ReaderT (const m)
\end{haskell}

Now we can add \texttt{IO} effects to \texttt{Reader}.

\begin{haskell}
greetWithConfig :: ReaderT Config IO ()
greetWithConfig = do
    conf <- ask
    lift (putStrLn (if (nice conf) then ``You're awesome!" else ``You suck!"))
\end{haskell}

\end{document}
